"""
Ã‡ok Kuyruklu Kapasite Planlama - DoÄŸru YaklaÅŸÄ±m
Kuyruk Ã¶nceliklendirme ve multi-skill modelleme
"""

import pandas as pd
import numpy as np
import math
from dataclasses import dataclass
from typing import List, Dict, Tuple


@dataclass
class QueueConfig:
    """Kuyruk konfigÃ¼rasyonu"""
    name: str
    aht: int  # saniye
    priority: int  # 1 = en yÃ¼ksek Ã¶ncelik
    

@dataclass
class SkillGroup:
    """Agent skill grubu"""
    name: str
    queues: List[str]  # Hangi kuyruklara bakabilir
    queue_priorities: Dict[str, int]  # Her kuyruk iÃ§in Ã¶ncelik


# KonfigÃ¼rasyon
CONFIG = {
    'target_sl': 0.80,
    'target_asa': 30,  # saniye
    'shrinkage': 0.10,
    'interval_minutes': 30
}

# Kuyruk tanÄ±mlarÄ±
QUEUES = {
    'A': QueueConfig(name='A', aht=180, priority=2),
    'B': QueueConfig(name='B', aht=180, priority=1),
    'C': QueueConfig(name='C', aht=200, priority=3)  # Yeni kuyruk Ã¶rneÄŸi
}

# Skill gruplarÄ± tanÄ±mlarÄ±
SKILL_GROUPS = {
    'A_only': SkillGroup(
        name='A_only',
        queues=['A'],
        queue_priorities={'A': 1}
    ),
    'B_multi': SkillGroup(
        name='B_multi',
        queues=['B', 'A'],  # B'ye bakabilir, sonra A'ya
        queue_priorities={'B': 1, 'A': 2}
    ),
    'C_multi': SkillGroup(
        name='C_multi',
        queues=['C', 'B', 'A'],  # Hepsine bakabilir
        queue_priorities={'C': 1, 'B': 2, 'A': 3}
    )
}


def erlang_c(agents, traffic):
    """Erlang C - Kuyrukta bekleme olasÄ±lÄ±ÄŸÄ±"""
    if agents <= traffic or agents == 0:
        return 1.0
    
    # Erlang B
    erlang_b = traffic / agents
    for i in range(2, int(agents) + 1):
        erlang_b = (traffic * erlang_b) / (i + traffic * erlang_b)
    
    # Erlang C
    erlang_c_val = erlang_b / (1 - (traffic / agents) * (1 - erlang_b))
    return min(erlang_c_val, 1.0)


def calculate_asa(agents, traffic, aht):
    """Average Speed to Answer hesapla"""
    if agents <= traffic:
        return 9999  # Yetersiz kapasite
    
    ec = erlang_c(agents, traffic)
    asa = (ec * (aht / 60)) / (agents - traffic) * 60  # saniye
    return asa


def calculate_traffic(calls, aht, interval_minutes):
    """Traffic intensity (Erlang) hesapla"""
    return (calls * (aht / 60)) / interval_minutes


def find_minimum_agents(calls, aht, interval_minutes, target_asa):
    """Hedef ASA'yÄ± saÄŸlayan minimum agent sayÄ±sÄ±"""
    if calls == 0:
        return 0
    
    traffic = calculate_traffic(calls, aht, interval_minutes)
    if traffic == 0:
        return 0
    
    min_agents = math.ceil(traffic)
    max_agents = math.ceil(traffic * 3) + 10
    
    for agents in range(min_agents, max_agents + 1):
        asa = calculate_asa(agents, traffic, aht)
        if asa <= target_asa:
            return agents
    
    return max_agents


# ============================================================================
# YAKLAÅIM 1: BaÄŸÄ±msÄ±z Hesaplama (Hafta Sonu Gibi)
# ============================================================================

def calculate_independent_queues(call_volumes: Dict[str, int]) -> Dict[str, int]:
    """
    Her kuyruk baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r, yardÄ±mlaÅŸma YOK
    Ã–rnek: Hafta sonu
    
    Args:
        call_volumes: {'A': 50, 'B': 30, 'C': 20}
    
    Returns:
        {'A_only': 10, 'B_only': 6, 'C_only': 4}
    """
    agent_needs = {}
    
    for queue_name, calls in call_volumes.items():
        queue = QUEUES[queue_name]
        agents = find_minimum_agents(
            calls,
            queue.aht,
            CONFIG['interval_minutes'],
            CONFIG['target_asa']
        )
        agent_needs[f"{queue_name}_only"] = agents
    
    return agent_needs


# ============================================================================
# YAKLAÅIM 2: Ã–ncelikli YardÄ±mlaÅŸma (Hafta Ä°Ã§i)
# ============================================================================

def calculate_with_priority_help(call_volumes: Dict[str, int], 
                                 help_enabled: bool = True) -> Dict[str, int]:
    """
    B agentlarÄ± Ã¶nce B'ye bakar, B yoksa A'ya yardÄ±m eder
    
    MantÄ±k:
    1. B kuyruÄŸu iÃ§in gereken dedicated agent sayÄ±sÄ±nÄ± bul
    2. A kuyruÄŸu iÃ§in gereken agent sayÄ±sÄ±nÄ± bul
    3. B agentlarÄ± A'ya yardÄ±m edebilir, bu yÃ¼zden A iÃ§in daha az dedicated agent gerekir
    
    Args:
        call_volumes: {'A': 100, 'B': 50}
        help_enabled: True ise B agentlarÄ± A'ya yardÄ±m eder
    
    Returns:
        {'A_only': X, 'B_multi': Y}
    """
    
    # 1. B kuyruÄŸu iÃ§in gereken agent (dedicated)
    b_calls = call_volumes.get('B', 0)
    b_agents_needed = find_minimum_agents(
        b_calls,
        QUEUES['B'].aht,
        CONFIG['interval_minutes'],
        CONFIG['target_asa']
    )
    
    if not help_enabled:
        # YardÄ±mlaÅŸma yoksa
        a_calls = call_volumes.get('A', 0)
        a_agents_needed = find_minimum_agents(
            a_calls,
            QUEUES['A'].aht,
            CONFIG['interval_minutes'],
            CONFIG['target_asa']
        )
        return {
            'A_only': a_agents_needed,
            'B_multi': b_agents_needed
        }
    
    # 2. B agentlarÄ± A'ya yardÄ±m edecek
    # Toplam A+B Ã§aÄŸrÄ±larÄ±nÄ± karÅŸÄ±layacak multi-skill agent sayÄ±sÄ±
    a_calls = call_volumes.get('A', 0)
    total_calls_ab = a_calls + b_calls
    
    # B agentlarÄ± hem A hem B'ye bakabilir
    # Toplam ihtiyaÃ§ hesapla (weighted average AHT ile)
    if total_calls_ab > 0:
        weighted_aht = (
            (a_calls * QUEUES['A'].aht + b_calls * QUEUES['B'].aht) / total_calls_ab
        )
    else:
        weighted_aht = QUEUES['A'].aht
    
    total_agents_needed = find_minimum_agents(
        total_calls_ab,
        weighted_aht,
        CONFIG['interval_minutes'],
        CONFIG['target_asa']
    )
    
    # 3. B agentlarÄ±: en az B kuyruÄŸu iÃ§in gereken kadar olmalÄ±
    b_multi_agents = max(b_agents_needed, 0)
    
    # 4. A dedicated agentlar: Toplam ihtiyaÃ§ - B agentlarÄ±nÄ±n katkÄ±sÄ±
    # B agentlarÄ± B'ye baktÄ±ktan sonra A'ya yardÄ±m eder
    remaining_for_a = max(0, total_agents_needed - b_multi_agents)
    a_only_agents = remaining_for_a
    
    return {
        'A_only': a_only_agents,
        'B_multi': b_multi_agents
    }


# ============================================================================
# YAKLAÅIM 3: GerÃ§ekÃ§i SimÃ¼lasyon (En DoÄŸru)
# ============================================================================

def calculate_with_simulation(call_volumes: Dict[str, int], 
                             skill_groups: Dict[str, SkillGroup],
                             max_iterations: int = 50) -> Dict[str, int]:
    """
    Ä°teratif yaklaÅŸÄ±m: Agent sayÄ±larÄ±nÄ± artÄ±rarak hedef ASA'yÄ± yakala
    
    Bu yÃ¶ntem en gerÃ§ekÃ§i sonucu verir Ã§Ã¼nkÃ¼:
    - Her skill grubunun Ã¶nceliklerini dikkate alÄ±r
    - B agentlarÄ±nÄ±n hem B hem A'ya bakarken nasÄ±l daÄŸÄ±ldÄ±ÄŸÄ±nÄ± modeller
    - Multi-queue senaryolarÄ±nÄ± handle eder
    """
    
    # BaÅŸlangÄ±Ã§: Her kuyruk iÃ§in baÄŸÄ±msÄ±z hesaplama
    agent_counts = {sg_name: 0 for sg_name in skill_groups.keys()}
    
    # Her skill grubu iÃ§in baÅŸlangÄ±Ã§ deÄŸeri
    for sg_name, sg in skill_groups.items():
        primary_queue = sg.queues[0]  # En yÃ¼ksek Ã¶ncelikli kuyruk
        if primary_queue in call_volumes:
            initial = find_minimum_agents(
                call_volumes[primary_queue],
                QUEUES[primary_queue].aht,
                CONFIG['interval_minutes'],
                CONFIG['target_asa']
            )
            agent_counts[sg_name] = initial
    
    # Ä°teratif iyileÅŸtirme
    for iteration in range(max_iterations):
        # Her kuyruk iÃ§in effective capacity hesapla
        effective_capacity = {}
        
        for queue_name in call_volumes.keys():
            capacity = 0
            
            # Bu kuyruÄŸa bakabilen tÃ¼m skill gruplarÄ±nÄ± bul
            for sg_name, sg in skill_groups.items():
                if queue_name in sg.queues:
                    # Bu skill grubunun bu kuyruÄŸa ayÄ±racaÄŸÄ± capacity
                    # (basitleÅŸtirilmiÅŸ - gerÃ§ekte Ã¶nceliklere gÃ¶re dinamik daÄŸÄ±lÄ±m yapÄ±lÄ±r)
                    capacity += agent_counts[sg_name]
            
            effective_capacity[queue_name] = capacity
        
        # Her kuyruk iÃ§in ASA hesapla ve yetersiz olanlarÄ± tespit et
        asa_results = {}
        for queue_name, calls in call_volumes.items():
            if calls == 0:
                asa_results[queue_name] = 0
                continue
                
            traffic = calculate_traffic(calls, QUEUES[queue_name].aht, CONFIG['interval_minutes'])
            agents = effective_capacity[queue_name]
            
            if agents > 0:
                asa = calculate_asa(agents, traffic, QUEUES[queue_name].aht)
                asa_results[queue_name] = asa
            else:
                asa_results[queue_name] = 9999
        
        # Hedefi saÄŸlamayan kuyruklarÄ± bul
        needs_improvement = [q for q, asa in asa_results.items() if asa > CONFIG['target_asa']]
        
        if not needs_improvement:
            # TÃ¼m kuyruklar hedefi saÄŸlÄ±yor
            break
        
        # En kÃ¶tÃ¼ kuyruÄŸa bakabilen skill grubunu artÄ±r
        worst_queue = max(needs_improvement, key=lambda q: asa_results[q])
        
        # Bu kuyruÄŸa bakabilen skill gruplarÄ±nÄ± bul
        eligible_groups = [
            sg_name for sg_name, sg in skill_groups.items() 
            if worst_queue in sg.queues
        ]
        
        if eligible_groups:
            # En yÃ¼ksek Ã¶nceliÄŸe sahip skill grubunu artÄ±r
            best_group = eligible_groups[0]  # BasitleÅŸtirilmiÅŸ
            agent_counts[best_group] += 1
    
    return agent_counts


# ============================================================================
# YAKLAÅIM 4: Pratik ve HÄ±zlÄ± (Ã–nerilen)
# ============================================================================

def calculate_practical_approach(call_volumes: Dict[str, int]) -> Dict[str, int]:
    """
    Pratik ve hÄ±zlÄ± yaklaÅŸÄ±m:
    
    1. B kuyruÄŸu iÃ§in gereken minimum B agentÄ± bul
    2. A kuyruÄŸu tek baÅŸÄ±na kaÃ§ agent ister bul
    3. B agentlarÄ±nÄ±n A'ya katkÄ±sÄ±nÄ± Ã§Ä±kar
    4. GÃ¼venlik faktÃ¶rÃ¼ ekle (%10-15)
    
    Bu en hÄ±zlÄ± ve en anlaÅŸÄ±lÄ±r yÃ¶ntem.
    """
    
    # 1. B kuyruÄŸu dedicated ihtiyacÄ±
    b_calls = call_volumes.get('B', 0)
    b_traffic = calculate_traffic(b_calls, QUEUES['B'].aht, CONFIG['interval_minutes'])
    b_agents_min = math.ceil(b_traffic)  # Minimum B agentÄ±
    
    # B iÃ§in hedef ASA'yÄ± saÄŸlayan agent
    b_agents_needed = find_minimum_agents(
        b_calls,
        QUEUES['B'].aht,
        CONFIG['interval_minutes'],
        CONFIG['target_asa']
    )
    
    # 2. A kuyruÄŸu tek baÅŸÄ±na ne ister
    a_calls = call_volumes.get('A', 0)
    a_agents_if_alone = find_minimum_agents(
        a_calls,
        QUEUES['A'].aht,
        CONFIG['interval_minutes'],
        CONFIG['target_asa']
    )
    
    # 3. B agentlarÄ±nÄ±n A'ya katkÄ±sÄ±
    # B agentlarÄ± B trafiÄŸini karÅŸÄ±ladÄ±ktan sonra kalan kapasiteleri A'ya verir
    # B utilization oranÄ±
    if b_agents_needed > 0:
        b_utilization = b_traffic / b_agents_needed
    else:
        b_utilization = 0
    
    # B agentlarÄ±nÄ±n A'ya vereceÄŸi effective kapasite
    # (1 - utilization) kadar boÅŸ kalÄ±rlar, bu kÄ±smÄ± A'ya verirler
    b_contribution_to_a = b_agents_needed * (1 - b_utilization) if b_utilization < 1 else 0
    
    # 4. A iÃ§in gereken dedicated agent
    a_only_needed = max(0, a_agents_if_alone - b_contribution_to_a)
    
    # 5. GÃ¼venlik faktÃ¶rÃ¼ (overflow iÃ§in)
    safety_factor = 1.10
    a_only_final = math.ceil(a_only_needed * safety_factor)
    b_multi_final = math.ceil(b_agents_needed * safety_factor)
    
    return {
        'A_only': a_only_final,
        'B_multi': b_multi_final,
        'details': {
            'b_utilization': round(b_utilization, 2),
            'b_contribution_to_a': round(b_contribution_to_a, 1),
            'a_if_alone': a_agents_if_alone,
            'a_after_help': a_only_final
        }
    }


# ============================================================================
# ANA FONKSÄ°YON: Interval bazlÄ± hesaplama
# ============================================================================

def calculate_staffing_for_interval(interval_data: pd.Series, 
                                   approach: str = 'practical',
                                   help_enabled: bool = True) -> Dict:
    """
    Tek bir zaman dilimi iÃ§in agent ihtiyacÄ±nÄ± hesapla
    
    Args:
        interval_data: time, queue_a, queue_b kolonlarÄ± olan Series
        approach: 'independent', 'priority', 'simulation', 'practical'
        help_enabled: Kuyruklar arasÄ± yardÄ±m var mÄ±?
    
    Returns:
        Agent ihtiyaÃ§larÄ± ve detaylar
    """
    
    call_volumes = {
        'A': interval_data['queue_a'],
        'B': interval_data['queue_b']
    }
    
    if approach == 'independent':
        agents = calculate_independent_queues(call_volumes)
    
    elif approach == 'priority':
        agents = calculate_with_priority_help(call_volumes, help_enabled)
    
    elif approach == 'simulation':
        agents = calculate_with_simulation(call_volumes, SKILL_GROUPS)
    
    elif approach == 'practical':
        result = calculate_practical_approach(call_volumes)
        agents = {k: v for k, v in result.items() if k != 'details'}
        
    else:
        raise ValueError(f"Unknown approach: {approach}")
    
    # Shrinkage ekle
    final_agents = {}
    for skill_group, count in agents.items():
        if skill_group != 'details':
            final_agents[skill_group] = math.ceil(count / (1 - CONFIG['shrinkage']))
    
    return {
        'time': interval_data['time'],
        'call_volumes': call_volumes,
        'raw_agents': agents,
        'final_agents': final_agents,
        'total': sum(final_agents.values())
    }


def calculate_daily_staffing(df: pd.DataFrame, 
                            approach: str = 'practical',
                            is_weekend: bool = False) -> pd.DataFrame:
    """
    TÃ¼m gÃ¼n iÃ§in agent ihtiyacÄ±nÄ± hesapla
    
    Args:
        df: time, queue_a, queue_b kolonlarÄ±
        approach: Hangi hesaplama yÃ¶ntemi
        is_weekend: Hafta sonu mu? (yardÄ±mlaÅŸma yok)
    """
    
    results = []
    help_enabled = not is_weekend
    
    for idx, row in df.iterrows():
        result = calculate_staffing_for_interval(row, approach, help_enabled)
        results.append(result)
    
    return pd.DataFrame(results)


# ============================================================================
# Ã–RNEK KULLANIM
# ============================================================================

if __name__ == '__main__':
    # Ã–rnek veri
    sample_data = pd.DataFrame({
        'time': ['09:00', '09:30', '10:00', '10:30', '11:00'],
        'queue_a': [80, 120, 150, 130, 100],
        'queue_b': [40, 50, 60, 55, 45]
    })
    
    print("=" * 80)
    print("KAPASÄ°TE PLANLAMA - KARÅILAÅTIRMA")
    print("=" * 80)
    
    # YaklaÅŸÄ±m 1: BaÄŸÄ±msÄ±z
    print("\n1ï¸âƒ£  BAÄIMSIZ (YardÄ±mlaÅŸma yok - Hafta Sonu)")
    print("-" * 80)
    result_independent = calculate_daily_staffing(sample_data, 'independent')
    print(result_independent[['time', 'final_agents', 'total']])
    
    # YaklaÅŸÄ±m 2: Pratik
    print("\n2ï¸âƒ£  PRATÄ°K YAKLAÅIM (Ã–nerilen - Hafta Ä°Ã§i)")
    print("-" * 80)
    result_practical = calculate_daily_staffing(sample_data, 'practical')
    print(result_practical[['time', 'final_agents', 'total']])
    
    # DetaylÄ± Ã¶rnek
    print("\n" + "=" * 80)
    print("DETAYLI Ã–RNEK: 10:00-10:30")
    print("=" * 80)
    
    example_interval = sample_data.iloc[2]
    print(f"\nÃ‡aÄŸrÄ± Hacmi:")
    print(f"  A KuyruÄŸu: {example_interval['queue_a']} Ã§aÄŸrÄ±")
    print(f"  B KuyruÄŸu: {example_interval['queue_b']} Ã§aÄŸrÄ±")
    
    result = calculate_practical_approach({
        'A': example_interval['queue_a'],
        'B': example_interval['queue_b']
    })
    
    print(f"\nğŸ“Š Hesaplama Sonucu:")
    print(f"  A AgentlarÄ± (dedicated): {result['A_only']}")
    print(f"  B AgentlarÄ± (multi-skill): {result['B_multi']}")
    print(f"  Toplam: {result['A_only'] + result['B_multi']}")
    
    print(f"\nğŸ” Detaylar:")
    for key, value in result['details'].items():
        print(f"  {key}: {value}")
    
    print("\n" + "=" * 80)
    print("âœ… Hesaplama tamamlandÄ±!")
    print("=" * 80)
