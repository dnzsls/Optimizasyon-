from pulp import *
import pandas as pd

# ----------------------------------------------------
# 1. VERİ TANIMLAMA
# ----------------------------------------------------

# Örnek Talep Verisi (Brüt Personel İhtiyacı - Shrinkage dahil)
# Bu değerler, Erlang C hesabı sonrası çıkan NİHAİ personel ihtiyacıdır.
# Senaryoyu basitleştirmek için tek bir 8 saatlik vardiya dönemine odaklanalım.
# İhtiyaç: Pazartesi - Pazar günleri için 8 saatlik vardiyada gerekli kişi sayısı.

# Kuyruk A (Yüksek Öncelikli/Uzmanlık Gerektiren) - Sadece A-Uzmanları ve B-Uzmanları (Yardım amaçlı)
DEMAND_A = {
    'Pzt': 10, 'Sal': 10, 'Çar': 10, 'Per': 10, 'Cum': 10,
    'Cmt': 12, 'Paz': 12
}

# Kuyruk B (Normal İş Yükü) - Sadece B-Uzmanları karşılayabilir.
DEMAND_B = {
    'Pzt': 8, 'Sal': 8, 'Çar': 8, 'Per': 8, 'Cum': 8,
    'Cmt': 5, 'Paz': 5
}

# Çalışan Tipleri ve Maliyet
CALISAN_GRUPLARI = ['A_Uzman', 'B_Uzman']
GUNLER = ['Pzt', 'Sal', 'Çar', 'Per', 'Cum', 'Cmt', 'Paz']

# Planlama kısıtları
MAX_CALISAN_SAYISI = 40 # Toplam mevcut çalışan sayısı
HAFTA_ICI = ['Pzt', 'Sal', 'Çar', 'Per', 'Cum']
HAFTA_SONU = ['Cmt', 'Paz']

# ----------------------------------------------------
# 2. OPTİMİZASYON MODELİNİ OLUŞTURMA
# ----------------------------------------------------

model = LpProblem("Coklu_Beceri_Vardiya_Planlama", LpMinimize)

# ----------------------------------------------------
# 3. KARAR DEĞİŞKENLERİ
# ----------------------------------------------------

# i çalışanın, g gününde vardiyada olup olmadığını gösterir (Binary değişken: 0 veya 1)
# Burada, çalışan tipi bazında kaç kişinin o gün vardiyaya atanacağını belirliyoruz.

# A-Uzmanı atamaları
X_A = LpVariable.dicts("Atama_A", (GUNLER), 0, MAX_CALISAN_SAYISI, LpInteger)

# B-Uzmanı atamaları
X_B = LpVariable.dicts("Atama_B", (GUNLER), 0, MAX_CALISAN_SAYISI, LpInteger)

# ----------------------------------------------------
# 4. AMAÇ FONKSİYONU
# ----------------------------------------------------

# Amaç: Atanan toplam çalışan sayısını (maliyeti) minimuma indirmek.
# Herkesin maliyetinin eşit olduğunu varsayalım (örneğin 1 birim).

model += lpSum([X_A[g] + X_B[g] for g in GUNLER]), "Toplam_Calisan_Maliyeti"

# ----------------------------------------------------
# 5. KISITLAR (CONSTRAINTS)
# ----------------------------------------------------

# Kısıt 1: B Kuyruğu Talep Kısıtı (Sadece B-Uzmanları karşılayabilir)
# B-Uzmanları, B kuyruğu talebini karşılamak zorundadır.
for g in GUNLER:
    model += X_B[g] >= DEMAND_B[g], f"Kisit_B_Talep_{g}"

# Kısıt 2: Kuyruk A Talep Kısıtı (Esneklik burada devreye girer)
# A kuyruğu talebi = A-Uzmanları + B-Uzmanlarından gelen destek

for g in GUNLER:
    if g in HAFTA_SONU:
        # Hafta Sonu: B-Uzmanları KENDİ kuyruğunda. A'ya YARDIM YOK.
        # Sadece A-Uzmanları A talebini karşılamak zorunda.
        model += X_A[g] >= DEMAND_A[g], f"Kisit_A_Talep_HS_{g}"
    
    else:
        # Hafta İçi: B-Uzmanları A'ya yardım edebilir.
        # A'ya atanan A-Uzmanları + (B'nin ihtiyacını karşıladıktan sonra kalan B-Uzmanları) >= A talebi
        
        # Bu kısıtı modellemek için:
        # A'nın kalan ihtiyacı, B'nin fazlası tarafından karşılanacak.
        
        # Basit Modelleme: B-Uzmanlarının tamamının A'ya destek verebileceğini kabul ederek
        model += X_A[g] + X_B[g] >= DEMAND_A[g], f"Kisit_A_Talep_HI_{g}"
        
        # NOT: Bu basit model, B'nin ihtiyacı karşılandıktan sonra A'ya destek gittiğini varsayar. 
        # Gerçek optimizasyon yazılımları, bu esnekliği B-Uzmanlarının B ve A arasındaki 
        # *zaman dilimi dağılımı* üzerinden daha karmaşık (ve doğru) şekilde çözer.
        
# Kısıt 3: Toplam Atanan B-Uzmanlarının Sayısı
# B-Uzmanları, hem B'yi karşılamak hem de A'ya yardım etmek zorundadır.
# Bu kısıt, B'nin minimum talebini garanti altına alırken, A'ya da destek sağlayacak şekilde 
# B-Uzmanlarının atanmasını sağlar (Kısıt 1 ve Kısıt 2 birlikte çalışır).

# Kısıt 4: Çalışan Kısıtı (Tüm Çalışan Sayısı)
# Atanan A ve B uzmanlarının haftalık toplamının, toplam çalışan sayısını aşmaması gerekir.
# (Bu model, her çalışanın sadece 1 vardiya çalıştığını varsayar, bu nedenle günlük atama = günlük farklı çalışan sayısıdır).

# En azından B grubuna atanması gereken toplam (haftalık) minimum çalışan sayısı:
# B-Grubu'nun günlük minimum talepleri ve 5 gün çalışma kısıtı (örnek bir ek kısıt)

# model += lpSum([X_A[g] for g in GUNLER]) + lpSum([X_B[g] for g in GUNLER]) <= MAX_CALISAN_SAYISI * 7 # Basit örnek
# Daha gerçekçi bir kısıt:
# Toplam (A+B) uzmanlarının haftalık toplamı, toplam kapasitemizi aşmamalı.
# (Gerçek hayatta bu, *toplam çalışan sayısı* ve *çalışma günü sayısı* üzerinden hesaplanır.)
model += lpSum([X_A[g] for g in GUNLER]) + lpSum([X_B[g] for g in GUNLER]) <= MAX_CALISAN_SAYISI * 7, "Maks_Haftalik_Atama"
# Bu, her bir çalışanın sadece bir gün çalıştığı varsayımıyla çalışır. Gerçekte, bir çalışan 5 gün çalışır.

# ----------------------------------------------------
# 6. MODELİ ÇÖZME VE SONUÇLARI GÖRÜNTÜLEME
# ----------------------------------------------------

# Modeli çöz
model.solve()

# Çözüm durumunu kontrol et
print(f"Durum: {LpStatus[model.status]}\n")

# Sonuçları DataFrame'e aktar
sonuclar = []
for g in GUNLER:
    A_atanan = value(X_A[g])
    B_atanan = value(X_B[g])
    
    # A kuyruğu için toplam personel (A+B yardımı)
    if g in HAFTA_SONU:
        # Hafta Sonu: Sadece A-Uzmanları
        A_toplam_karsilayan = A_atanan
        B_A_destek = 0
    else:
        # Hafta İçi: B'den A'ya destek var
        # B'nin ihtiyacını karşılamak için B_atanan'ın bir kısmı B'de kalır (DEMAND_B[g])
        # Geri kalanı A'ya destek olur.
        B_A_destek = max(0, B_atanan - DEMAND_B[g])
        A_toplam_karsilayan = A_atanan + B_A_destek

    sonuclar.append({
        'Gün': g,
        'A Talep': DEMAND_A[g],
        'B Talep': DEMAND_B[g],
        'Atanan A-Uzmanları': A_atanan,
        'Atanan B-Uzmanları': B_atanan,
        'A Kuyruğunu Karşılayan TOPLAM': A_toplam_karsilayan,
        'B'den A\'ya Destek (H.Içi)': B_A_destek if g in HAFTA_ICI else 'N/A',
        'A Karsilandi mi?': 'EVET' if A_toplam_karsilayan >= DEMAND_A[g] else 'HAYIR',
        'B Karsilandi mi?': 'EVET' if B_atanan >= DEMAND_B[g] else 'HAYIR'
    })

df_sonuc = pd.DataFrame(sonuclar)

print("--- Planlama Sonuçları (Personel Sayısı) ---")
print(df_sonuc.to_markdown(index=False, floatfmt=".0f"))
print(f"\nMinimum Toplam Çalışan Gün Sayısı: {value(model.objective):.0f}")

# NOT: Hafta içi A kuyruğunu karşılama mantığı (Kısıt 2'de) B uzmanlarının esnekliğini kullanarak 
# A'nın talebini karşılarken, B'nin talebi (Kısıt 1'de) zaten garantilenmiştir. 
# Bu, "B'nin fazlası A'ya yardım eder" mantığının matematiksel optimizasyon ile yansımasıdır.
