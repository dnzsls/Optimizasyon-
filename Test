# =========================================================
# MULTI-REASON THRESHOLD ANALYSIS (1D & 2D) — EXPLAINED
# =========================================================
# Bu paket, her "call reason" için olasılık → sınıf (0/1) dönüşümü
# eşiklerini sistematik tarar ve en iyi eşiği (ya da precision≥hedef
# altında en iyi recall) otomatik seçer. 1D ve 2D (overall ∧ reason)
# seçenekleriyle çalışır; çoklu reason için toplu özet üretir.
# =========================================================

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
import numpy as np
import pandas as pd
from sklearn.metrics import (
    precision_score, recall_score, f1_score, accuracy_score,
    roc_auc_score, brier_score_loss
)
from sklearn.isotonic import IsotonicRegression

# ------------------------------
# Küçük yardımcılar
# ------------------------------

def _bin(y_prob: np.ndarray, thr: float) -> np.ndarray:
    """Olasılıkları eşiğe göre (>=thr) 0/1'e çevir."""
    return (y_prob >= thr).astype(int)

def _safe_precision(y_true, y_pred) -> float:
    return precision_score(y_true, y_pred, zero_division=0)

def _safe_recall(y_true, y_pred) -> float:
    return recall_score(y_true, y_pred, zero_division=0)

def _prevalence(y_true: np.ndarray) -> float:
    """Pozitif taban oranı (base rate)."""
    return float(np.mean(y_true))

def _lift(y_true: np.ndarray, y_pred: np.ndarray) -> float:
    """(Pozitif tahminlerdeki gerçek pozitif oranı) / (taban pozitif oranı)."""
    if y_pred.sum() == 0:
        return np.nan
    pos_rate_pred = np.mean(y_true[y_pred == 1])
    base = _prevalence(y_true)
    return pos_rate_pred / base if base > 0 else np.nan

# --------------------------------------------
# 1D tarama: yalnızca reason olasılığı
# --------------------------------------------

def sweep_thresholds_1d(
    y_true: np.ndarray,
    y_prob: np.ndarray,
    grid: Optional[np.ndarray] = None
) -> pd.DataFrame:
    """
    Tek değişkenli eşik taraması: y_pred = (y_prob >= t).

    Dönüş: DataFrame (threshold, precision, recall, f1, accuracy, lift),
    df.attrs içinde base_prevalence, roc_auc, brier özetleri.
    """
    if grid is None:
        grid = np.round(np.linspace(0.0, 1.0, 201), 3)  # 0.005 adım

    rows = []
    for thr in grid:
        y_pred = _bin(y_prob, thr)
        rows.append({
            "threshold": thr,
            "precision": _safe_precision(y_true, y_pred),
            "recall":    _safe_recall(y_true, y_pred),
            "f1":        f1_score(y_true, y_pred, zero_division=0),
            "accuracy":  accuracy_score(y_true, y_pred),
            "lift":      _lift(y_true, y_pred),
        })

    df = pd.DataFrame(rows)
    df.attrs["base_prevalence"] = _prevalence(y_true)
    try:    df.attrs["roc_auc"] = roc_auc_score(y_true, y_prob)
    except: df.attrs["roc_auc"] = np.nan
    try:    df.attrs["brier"] = brier_score_loss(y_true, y_prob)
    except: df.attrs["brier"] = np.nan
    return df

# --------------------------------------------------------
# 2D tarama: overall ∧ reason (precision'ı artırmak için)
# --------------------------------------------------------

def sweep_thresholds_2d(
    y_true: np.ndarray,
    p_overall: np.ndarray,
    p_reason: np.ndarray,
    grid_overall: Optional[np.ndarray] = None,
    grid_reason: Optional[np.ndarray] = None
) -> pd.DataFrame:
    """
    Çift kapı: y_pred = (p_overall >= t_overall) ∧ (p_reason >= t_reason).
    """
    if grid_overall is None:
        grid_overall = np.round(np.linspace(0.0, 1.0, 21), 2)  # 0.05 adım
    if grid_reason is None:
        grid_reason  = np.round(np.linspace(0.0, 1.0, 21), 2)

    rows = []
    for t1 in grid_overall:
        for t2 in grid_reason:
            y_pred = ((p_overall >= t1) & (p_reason >= t2)).astype(int)
            rows.append({
                "t_overall": t1,
                "t_reason":  t2,
                "precision": _safe_precision(y_true, y_pred),
                "recall":    _safe_recall(y_true, y_pred),
                "f1":        f1_score(y_true, y_pred, zero_division=0),
                "accuracy":  accuracy_score(y_true, y_pred),
                "lift":      _lift(y_true, y_pred),
            })
    return pd.DataFrame(rows)

# ---------------------------------------
# Eşik seçimi stratejileri (otomatik)
# ---------------------------------------

@dataclass
class ThresholdPick:
    """Seçilmiş eşik(ler) ve metrik özeti."""
    strategy: str
    # 1D
    threshold: Optional[float] = None
    # 2D
    t_overall: Optional[float] = None
    t_reason:  Optional[float] = None
    # metrics
    precision: float = np.nan
    recall:    float = np.nan
    f1:        float = np.nan
    accuracy:  float = np.nan
    lift:      float = np.nan

def pick_from_1d(df: pd.DataFrame, precision_floor: Optional[float] = None) -> Dict[str, ThresholdPick]:
    """
    1D seçim:
      - best_f1
      - precision≥hedef ise recall maks (yoksa en yüksek precision fallback)
    """
    picks: Dict[str, ThresholdPick] = {}

    # best_f1
    r = df.sort_values(["f1", "recall", "precision"], ascending=[False, False, False]).iloc[0]
    picks["best_f1"] = ThresholdPick(
        strategy="best_f1",
        threshold=float(r.threshold),
        precision=float(r.precision),
        recall=float(r.recall),
        f1=float(r.f1),
        accuracy=float(r.accuracy),
        lift=float(r.lift) if pd.notna(r.lift) else np.nan
    )

    if precision_floor is not None:
        cand = df[df["precision"] >= precision_floor]
        if len(cand):
            r2 = cand.sort_values(["recall", "f1"], ascending=[False, False]).iloc[0]
            key = f"precision>={precision_floor:.2f}"
            picks[key] = ThresholdPick(
                strategy=key,
                threshold=float(r2.threshold),
                precision=float(r2.precision),
                recall=float(r2.recall),
                f1=float(r2.f1),
                accuracy=float(r2.accuracy),
                lift=float(r2.lift) if pd.notna(r2.lift) else np.nan
            )
        else:
            r3 = df.sort_values(["precision", "recall"], ascending=[False, False]).iloc[0]
            key = f"precision~{precision_floor:.2f}_fallback"
            picks[key] = ThresholdPick(
                strategy=key,
                threshold=float(r3.threshold),
                precision=float(r3.precision),
                recall=float(r3.recall),
                f1=float(r3.f1),
                accuracy=float(r3.accuracy),
                lift=float(r3.lift) if pd.notna(r3.lift) else np.nan
            )
    return picks

def pick_from_2d(df2: pd.DataFrame, precision_floor: Optional[float] = None) -> Dict[str, ThresholdPick]:
    """
    2D seçim:
      - best_f1
      - precision≥hedef ise recall maks (yoksa en yüksek precision fallback)
    """
    picks: Dict[str, ThresholdPick] = {}

    r = df2.sort_values(["f1", "recall", "precision"], ascending=[False, False, False]).iloc[0]
    picks["best_f1"] = ThresholdPick(
        strategy="best_f1_2d",
        t_overall=float(r.t_overall),
        t_reason=float(r.t_reason),
        precision=float(r.precision),
        recall=float(r.recall),
        f1=float(r.f1),
        accuracy=float(r.accuracy),
        lift=float(r.lift) if pd.notna(r.lift) else np.nan
    )

    if precision_floor is not None:
        cand = df2[df2["precision"] >= precision_floor]
        if len(cand):
            r2 = cand.sort_values(["recall", "f1"], ascending=[False, False]).iloc[0]
            key = f"precision>={precision_floor:.2f}_2d"
            picks[key] = ThresholdPick(
                strategy=key,
                t_overall=float(r2.t_overall),
                t_reason=float(r2.t_reason),
                precision=float(r2.precision),
                recall=float(r2.recall),
                f1=float(r2.f1),
                accuracy=float(r2.accuracy),
                lift=float(r2.lift) if pd.notna(r2.lift) else np.nan
            )
        else:
            r3 = df2.sort_values(["precision", "recall"], ascending=[False, False]).iloc[0]
            key = f"precision~{precision_floor:.2f}_fallback_2d"
            picks[key] = ThresholdPick(
                strategy=key,
                t_overall=float(r3.t_overall),
                t_reason=float(r3.t_reason),
                precision=float(r3.precision),
                recall=float(r3.recall),
                f1=float(r3.f1),
                accuracy=float(r3.accuracy),
                lift=float(r3.lift) if pd.notna(r3.lift) else np.nan
            )
    return picks

# -------------------------------------------------
# (Opsiyonel) Kalibrasyon — isotonic örneği
# -------------------------------------------------

def isotonic_calibrate(y_prob_valid: np.ndarray, y_true_valid: np.ndarray,
                       y_prob_test: np.ndarray) -> np.ndarray:
    """
    VALID üzerinde isotonic ile kalibre et, TEST olasılıklarını dönüştür.
    """
    ir = IsotonicRegression(out_of_bounds="clip")
    ir.fit(y_prob_valid, y_true_valid)
    return ir.transform(y_prob_test)

# -------------------------------------------------
# Çoklu reason için üst seviye sarmallar (1D & 2D)
# -------------------------------------------------

def analyze_many_reasons_1d(
    df: pd.DataFrame,
    reason_map: Dict[str, Tuple[str, str]],
    # ör: {"x1a": ("prob_x1a","flag_x1a"), "x2a": ("prob_x2a","flag_x2a"), ...}
    precision_floor_by_reason: Optional[Dict[str, float]] = None,
    grid: Optional[np.ndarray] = None
) -> Tuple[Dict[str, Dict[str, object]], pd.DataFrame]:
    """
    Her reason için 1D tarama & seçim yapar.
    Dönüş:
      - results: {reason: {"metrics": df, "summary": {...}, "picks": {...}}}
      - summary_df: reason başına satır (best_f1 ve varsa precision≥hedef)
    """
    all_results: Dict[str, Dict[str, object]] = {}
    rows = []

    for reason, (prob_col, flag_col) in reason_map.items():
        y_prob = df[prob_col].values.astype(float)
        y_true = df[flag_col].values.astype(int)

        met = sweep_thresholds_1d(y_true, y_prob, grid=grid)
        pf = None
        if precision_floor_by_reason and reason in precision_floor_by_reason:
            pf = float(precision_floor_by_reason[reason])
        picks = pick_from_1d(met, precision_floor=pf)

        # toplanacak özet
        all_results[reason] = {
            "metrics": met,
            "summary": {
                "base_prevalence": met.attrs.get("base_prevalence", np.nan),
                "roc_auc": met.attrs.get("roc_auc", np.nan),
                "brier": met.attrs.get("brier", np.nan)
            },
            "picks": picks
        }

        # Tabloya "best_f1" satırı
        p1 = picks["best_f1"]
        rows.append({
            "reason": reason, "strategy": p1.strategy,
            "threshold": p1.threshold, "precision": p1.precision,
            "recall": p1.recall, "f1": p1.f1, "accuracy": p1.accuracy,
            "lift": p1.lift,
            "base_prev": met.attrs.get("base_prevalence", np.nan),
            "roc_auc": met.attrs.get("roc_auc", np.nan),
            "brier": met.attrs.get("brier", np.nan),
        })

        # Tabloya precision≥hedef satırı (varsa)
        if pf is not None:
            key = [k for k in picks.keys() if k.startswith("precision")][0]
            p2 = picks[key]
            rows.append({
                "reason": reason, "strategy": p2.strategy,
                "threshold": p2.threshold, "precision": p2.precision,
                "recall": p2.recall, "f1": p2.f1, "accuracy": p2.accuracy,
                "lift": p2.lift,
                "base_prev": met.attrs.get("base_prevalence", np.nan),
                "roc_auc": met.attrs.get("roc_auc", np.nan),
                "brier": met.attrs.get("brier", np.nan),
            })

    summary_df = pd.DataFrame(rows).sort_values(["reason", "strategy"]).reset_index(drop=True)
    return all_results, summary_df


def analyze_many_reasons_2d(
    df: pd.DataFrame,
    reason_map_2d: Dict[str, Tuple[str, str, str]],
    # ör: {"x1a": ("prob_call_overall","prob_x1a","flag_x1a"), ...}
    precision_floor_by_reason: Optional[Dict[str, float]] = None,
    grid_overall: Optional[np.ndarray] = None,
    grid_reason: Optional[np.ndarray] = None
) -> Tuple[Dict[str, Dict[str, object]], pd.DataFrame]:
    """
    Her reason için 2D tarama & seçim yapar (overall ∧ reason).
    Dönüş:
      - results: {reason: {"metrics_2d": df, "picks_2d": {...}}}
      - summary_df: reason başına satır (best_f1_2d ve varsa precision≥hedef_2d)
    """
    all_results: Dict[str, Dict[str, object]] = {}
    rows = []

    for reason, (overall_col, prob_col, flag_col) in reason_map_2d.items():
        y_true   = df[flag_col].values.astype(int)
        p_all    = df[overall_col].values.astype(float)
        p_reason = df[prob_col].values.astype(float)

        met2 = sweep_thresholds_2d(y_true, p_all, p_reason, grid_overall, grid_reason)
        pf = None
        if precision_floor_by_reason and reason in precision_floor_by_reason:
            pf = float(precision_floor_by_reason[reason])
        picks2 = pick_from_2d(met2, precision_floor=pf)

        all_results[reason] = {"metrics_2d": met2, "picks_2d": picks2}

        # best_f1_2d
        p1 = picks2["best_f1_2d"]
        rows.append({
            "reason": reason, "strategy": p1.strategy,
            "t_overall": p1.t_overall, "t_reason": p1.t_reason,
            "precision": p1.precision, "recall": p1.recall,
            "f1": p1.f1, "accuracy": p1.accuracy, "lift": p1.lift
        })

        # precision≥hedef_2d (varsa)
        if pf is not None:
            key = [k for k in picks2.keys() if k.startswith("precision")][0]
            p2 = picks2[key]
            rows.append({
                "reason": reason, "strategy": p2.strategy,
                "t_overall": p2.t_overall, "t_reason": p2.t_reason,
                "precision": p2.precision, "recall": p2.recall,
                "f1": p2.f1, "accuracy": p2.accuracy, "lift": p2.lift
            })

    summary_df = pd.DataFrame(rows).sort_values(["reason", "strategy"]).reset_index(drop=True)
    return all_results, summary_df


# ======================
# ÖRNEK KULLANIM (mini)
# ======================
if __name__ == "__main__":
    # Örnek: 2 reason (x1a, x2a). Wide şema:
    # prob_x1a, flag_x1a, prob_x2a, flag_x2a, ve genel: prob_call_overall
    demo = pd.DataFrame({
        "musteri_id": [1,2,3,4,5,6,7,8],
        "prob_call_overall": [0.90,0.80,0.60,0.40,0.30,0.20,0.15,0.05],
        "prob_x1a": [0.82,0.77,0.60,0.55,0.35,0.22,0.18,0.05],
        "flag_x1a": [1,1,1,0,0,0,0,0],
        "prob_x2a": [0.10,0.20,0.25,0.40,0.50,0.70,0.90,0.95],
        "flag_x2a": [0,0,0,0,1,1,1,1],
    })

    # --- 1D: her reason için farklı eşik seç (best_f1 + precision≥hedef) ---
    reason_map_1d = {
        "x1a": ("prob_x1a", "flag_x1a"),
        "x2a": ("prob_x2a", "flag_x2a"),
    }
    precision_targets = {
        "x1a": 0.75,   # ör: x1a'da 0.75+ precision isterim
        "x2a": 0.98,   # ör: x2a'da 0.98+ precision isterim
    }
    results_1d, summary_1d = analyze_many_reasons_1d(
        df=demo,
        reason_map=reason_map_1d,
        precision_floor_by_reason=precision_targets,
        grid=None   # default 0.005 adımlı grid
    )
    print("\n[1D] Reason bazlı özet:")
    print(summary_1d)

    # --- 2D: overall ∧ reason eşikleri (genelde precision artar) ---
    reason_map_2d = {
        "x1a": ("prob_call_overall", "prob_x1a", "flag_x1a"),
        "x2a": ("prob_call_overall", "prob_x2a", "flag_x2a"),
    }
    results_2d, summary_2d = analyze_many_reasons_2d(
        df=demo,
        reason_map_2d=reason_map_2d,
        precision_floor_by_reason=precision_targets,
        grid_overall=None,  # default 0.05 adım
        grid_reason=None
    )
    print("\n[2D] Reason bazlı özet:")
    print(summary_2d)
