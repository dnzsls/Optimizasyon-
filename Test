import pandas as pd
import numpy as np
from typing import Optional, List

def optimize_threshold_reason1_only(
    df: pd.DataFrame,
    *,
    min_count: int = 500,        # en az kaç müşteri olmalı
    grid_step: float = 0.01,     # eşik aralığı (0.00..1.00)
    reasons: Optional[List[str]] = None,
    unique_customers: bool = True
) -> pd.DataFrame:
    """
    Sadece reason1_pred/reason1_prob ve true_reason'a bakarak
    her true_reason için reason1_best_th eşiğini seçer (precision maks., min_count kısıtı).
    
    Beklenen kolonlar:
      customer_id, reason1_pred, reason1_prob, true_reason
    """
    required = ["customer_id", "reason1_pred", "reason1_prob", "true_reason"]
    miss = [c for c in required if c not in df.columns]
    if miss:
        raise ValueError(f"Eksik kolon(lar): {miss}")

    data = df.copy()

    # Çalışılacak reason listesi
    if reasons is None:
        reasons = sorted(data["true_reason"].dropna().astype(str).unique().tolist())

    grid = np.round(np.arange(0.0, 1.0 + 1e-9, grid_step), 4)

    def _count(mask, ids, uniq): 
        return int(pd.Series(ids[mask]).nunique()) if uniq else int(mask.sum())

    def _tp(mask, ids, y_true, uniq):
        if uniq:
            d = pd.DataFrame({"id": ids[mask], "y": y_true[mask]})
            if d.empty: return 0
            return int(d.groupby("id")["y"].max().sum())   # müşteri bazında en az bir doğru
        else:
            return int(y_true[mask].sum())

    rows = []
    ids_all = data["customer_id"].to_numpy()
    r1_prob = data["reason1_prob"].to_numpy()
    # true/1 ve pred eşleşmeleri reason bazında oluşturulacak

    for r in reasons:
        y_true = (data["true_reason"].astype(str) == str(r)).to_numpy().astype(int)
        r1_pred_eq = (data["reason1_pred"].astype(str) == str(r)).to_numpy()

        best = dict(t=np.nan, n=0, tp=0, prec=-1.0, fallback=True)

        for t in grid:
            mask = r1_pred_eq & (r1_prob >= t)
            n  = _count(mask, ids_all, unique_customers)
            if n == 0:
                continue
            tp = _tp(mask, ids_all, y_true, unique_customers)
            prec = tp / n if n else 0.0
            qualifies = n >= min_count

            better = False
            if qualifies and (best["fallback"] or prec > best["prec"]):
                better = True
            elif not qualifies and best["fallback"] and (prec > best["prec"]):
                better = True
            elif prec == best["prec"]:
                if tp > best["tp"]:
                    better = True
                elif tp == best["tp"] and n < best["n"]:
                    better = True
                elif tp == best["tp"] and n == best["n"] and t > (best["t"] if not np.isnan(best["t"]) else -1):
                    better = True

            if better:
                best.update(dict(t=t, n=n, tp=tp, prec=prec, fallback=not qualifies))

        rows.append({
            "reason": r,
            "reason1_best_th": best["t"],
            "predicted_count": best["n"],       # (tekil müşteri sayısı, unique_customers=True ise)
            "true_positives": best["tp"],
            "precision": np.round(best["prec"], 6) if best["prec"] >= 0 else np.nan,
            "fallback": best["fallback"]        # min_count sağlanamadıysa True
        })

    return pd.DataFrame(rows).sort_values(
        ["fallback", "precision"], ascending=[Tr]()
