# =============================================
# TEK TAHMİN (reason1) - MÜŞTERİ veya MÜŞTERİ-GÜN bazında
# =============================================
import pandas as pd
import numpy as np
from typing import Optional, List

def optimize_threshold_reason1_grouped(
    df: pd.DataFrame,
    *,
    min_count: int = 500,
    grid_step: float = 0.01,
    base_call_floor: Optional[float] = 0.70,  # None -> call_prob filtresi yok
    session_cols: Optional[List[str]] = None, # ["customer_id"] veya ["customer_id","call_day"]
    reasons: Optional[List[str]] = None
) -> pd.DataFrame:
    must = ["customer_id", "reason1_pred", "reason1_prob", "true_reason"]
    miss = [c for c in must if c not in df.columns]
    if miss:
        raise ValueError(f"Eksik kolon(lar): {miss}")
    if base_call_floor is not None and "call_prob" not in df.columns:
        raise ValueError("base_call_floor kullanacaksan 'call_prob' kolonu gerekli. Ya call_prob ekle ya da base_call_floor=None yap.")

    data = df.copy()
    for c in ["reason1_pred", "true_reason"]:
        data[c] = data[c].astype(str).str.strip()

    # arama ihtimali filtresi
    if base_call_floor is not None:
        data = data.loc[data["call_prob"] >= float(base_call_floor)].copy()
        if data.empty:
            return pd.DataFrame(columns=["reason","call_prob_floor","reason1_best_th",
                                         "predicted_units","true_positives","precision","fallback"])

    # müşteri / müşteri-gün bazında tekilleştirme
    if session_cols is None:
        session_cols = ["customer_id"]
    unit_key = data[session_cols].astype(str).agg("§".join, axis=1)
    data = data.assign(_unit=unit_key.values)

    # reason listesi
    if reasons is None:
        reasons = sorted(data["true_reason"].dropna().unique().tolist())

    grid = np.round(np.arange(0.0, 1.0 + 1e-9, grid_step), 4)
    def any_by_unit(mask_bool: np.ndarray) -> pd.Series:
        return pd.Series(mask_bool, index=data.index).groupby(data["_unit"]).any()

    results = []

    for r in reasons:
        r_eq = (data["reason1_pred"] == r).to_numpy()
        p    = data["reason1_prob"].to_numpy()
        yrow = (data["true_reason"] == r).to_numpy()
        y_unit_true = pd.Series(yrow, index=data.index).groupby(data["_unit"]).any()

        best = dict(t=np.nan, n=0, tp=0, prec=-1.0, fallback=True)

        for t in grid:
            m = r_eq & (p >= t)
            pred_unit = any_by_unit(m)

            n = int(pred_unit.sum())
            if n == 0:
                continue
            tp = int((pred_unit & y_unit_true).sum())
            prec = tp / n if n else 0.0
            qualifies = n >= min_count

            better = False
            if qualifies and (best["fallback"] or prec > best["prec"]):
                better = True
            elif not qualifies and best["fallback"] and (prec > best["prec"]):
                better = True
            elif prec == best["prec"]:
                if tp > best["tp"]:
                    better = True
                elif tp == best["tp"] and n < best["n"]:
                    better = True
                elif tp == best["tp"] and n == best["n"] and t > (best["t"] if not np.isnan(best["t"]) else -1):
                    better = True

            if better:
                best.update(dict(t=t, n=n, tp=tp, prec=prec, fallback=not qualifies))

        results.append({
            "reason": r,
            "call_prob_floor": (None if base_call_floor is None else float(base_call_floor)),
            "reason1_best_th": best["t"],
            "predicted_units": best["n"],
            "true_positives": best["tp"],
            "precision": (np.round(best["prec"], 6) if best["prec"] >= 0 else np.nan),
            "fallback": best["fallback"]
        })

    out = pd.DataFrame(results).sort_values(["fallback","precision"], ascending=[True,False]).reset_index(drop=True)
    return out

# ================================
# 🔹 ÇALIŞTIRMA ÖRNEKLERİ
# ================================

# 1️⃣  Sadece müşteri bazında, arama ihtimali (call_prob) dahil:
result_customer = optimize_threshold_reason1_grouped(
    df,
    min_count=500,          # en az 500 müşteri
    grid_step=0.01,
    base_call_floor=0.70,   # call_prob ≥ 0.70
    session_cols=["customer_id"]
)
print("\n=== Müşteri bazında sonuç (call_prob dahil) ===")
print(result_customer.to_string(index=False))

# 2️⃣  Müşteri-gün bazında, arama ihtimali olmadan:
# eğer df'te 'call_day' varsa (ör: df["call_day"] = pd.to_datetime(df["call_time"]).dt.date)
result_day = optimize_threshold_reason1_grouped(
    df,
    min_count=500,
    grid_step=0.01,
    base_call_floor=None,   # call_prob kullanılmaz
    session_cols=["customer_id","call_day"]
)
print("\n=== Müşteri-GÜN bazında sonuç (call_prob yok) ===")
print(result_day.to_string(index=False))
