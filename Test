"""
KOMPLE KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V2
ASA + Service Level (Saatlik ASA + GÃ¼nlÃ¼k Takip + AylÄ±k Hedef)
Peak Ã–ncelikli Vardiya DaÄŸÄ±tÄ±mÄ±
Compliance Rate Takibi

GÃ¼ncellemeler:
- min_sl floor eklendi (%75 altÄ±na dÃ¼ÅŸmez)
- Compliance rate fonksiyonu eklendi (%75-85 aralÄ±k takibi)
"""
import pandas as pd
import math

# ============================================================================
# KONFIGURASYON
# ============================================================================

CONFIG = {
    'aht': 180,              # Average Handle Time - saniye
    'target_asa': 30,        # Hedef ASA - saniye
    'target_sl': 0.80,       # Hedef Service Level - %80
    'min_sl': 0.75,          # Minimum SL floor - %75 (asla altÄ±na dÃ¼ÅŸmez)
    'target_seconds': 30,    # SL iÃ§in hedef sÃ¼re - saniye
    'sl_tolerance': 0.02,    # SL tolerans (Â±%2)
    'shrinkage': 0.10,       # Mola/izin payÄ± - %10
    'interval_minutes': 60,  # Ä°nterval - dakika
    'peak_hours': {
        'start': 9,          # Peak baÅŸlangÄ±Ã§
        'end': 18            # Peak bitiÅŸ
    },
    'compliance': {
        'min_sl': 75,        # Compliance alt sÄ±nÄ±r %
        'max_sl': 85         # Compliance Ã¼st sÄ±nÄ±r %
    }
}


# ============================================================================
# BÃ–LÃœM 1: ERLANG C TEMELLERÄ°
# ============================================================================

def erlang_c(agents, traffic):
    """
    Erlang C: Kuyrukta bekleme olasÄ±lÄ±ÄŸÄ±
    
    Parametreler:
        agents: Agent sayÄ±sÄ±
        traffic: Erlang cinsinden trafik yoÄŸunluÄŸu
    
    DÃ¶ndÃ¼rÃ¼r:
        0-1 arasÄ± olasÄ±lÄ±k deÄŸeri
    """
    if agents <= traffic or agents == 0:
        return 1.0
    
    # Erlang B hesapla (meÅŸgul olasÄ±lÄ±ÄŸÄ±)
    erlang_b = traffic / agents
    for i in range(2, int(agents) + 1):
        erlang_b = (traffic * erlang_b) / (i + traffic * erlang_b)
    
    # Erlang C = Erlang B'den tÃ¼retilir
    erlang_c_val = erlang_b / (1 - (traffic / agents) * (1 - erlang_b))
    return min(erlang_c_val, 1.0)


def calculate_asa(agents, traffic, aht):
    """
    ASA (Average Speed to Answer) hesapla
    
    Parametreler:
        agents: Agent sayÄ±sÄ±
        traffic: Erlang cinsinden trafik
        aht: Average Handle Time (saniye)
    
    DÃ¶ndÃ¼rÃ¼r:
        ASA deÄŸeri (saniye)
    """
    if agents <= traffic or agents == 0:
        return 999
    
    ec = erlang_c(agents, traffic)
    asa = (ec * (aht / 60)) / (agents - traffic) * 60
    return asa


def calculate_service_level(agents, traffic, aht, target_seconds):
    """
    Service Level hesapla
    
    Parametreler:
        agents: Agent sayÄ±sÄ±
        traffic: Erlang cinsinden trafik
        aht: Average Handle Time (saniye)
        target_seconds: Hedef cevaplama sÃ¼resi (saniye)
    
    DÃ¶ndÃ¼rÃ¼r:
        0-1 arasÄ± SL deÄŸeri (Ã¶rn: 0.80 = %80)
    """
    if agents <= traffic or agents == 0:
        return 0.0
    
    ec = erlang_c(agents, traffic)
    exp_term = math.exp(-(agents - traffic) * (target_seconds / aht))
    sl = 1 - (ec * exp_term)
    
    return max(0, min(1, sl))


def calculate_traffic(calls, interval_min, aht):
    """
    Traffic (Erlang) hesapla
    
    Parametreler:
        calls: Ã‡aÄŸrÄ± sayÄ±sÄ±
        interval_min: Ä°nterval sÃ¼resi (dakika)
        aht: Average Handle Time (saniye)
    
    DÃ¶ndÃ¼rÃ¼r:
        Erlang cinsinden trafik deÄŸeri
    """
    if calls == 0:
        return 0
    return (calls * (aht / 60)) / interval_min


# ============================================================================
# BÃ–LÃœM 2: AGENT SAYISI BULMA (ASA + SL)
# ============================================================================

def find_agents_for_asa(calls, interval_min, aht, target_asa):
    """
    ASA hedefi iÃ§in gereken agent sayÄ±sÄ±
    
    ADIM ADIM:
    1. Ã‡aÄŸrÄ± yoksa â†’ 0 agent dÃ¶ndÃ¼r
    2. Traffic hesapla (Erlang)
    3. Minimum agent = ceil(traffic) â†’ en az bu kadar lazÄ±m
    4. YukarÄ± doÄŸru tara, ASA â‰¤ hedef olan ilk deÄŸeri bul
    
    Parametreler:
        calls: Ã‡aÄŸrÄ± sayÄ±sÄ±
        interval_min: Ä°nterval sÃ¼resi (dakika)
        aht: Average Handle Time (saniye)
        target_asa: Hedef ASA (saniye)
    
    DÃ¶ndÃ¼rÃ¼r:
        Gereken agent sayÄ±sÄ±
    """
    # ADIM 1: Ã‡aÄŸrÄ± kontrolÃ¼
    if calls == 0:
        return 0
    
    # ADIM 2: Traffic hesapla
    traffic = calculate_traffic(calls, interval_min, aht)
    if traffic == 0:
        return 0
    
    # ADIM 3: Arama aralÄ±ÄŸÄ±nÄ± belirle
    min_agents = math.ceil(traffic)      # En az traffic kadar agent lazÄ±m
    max_agents = math.ceil(traffic * 2) + 5  # Ãœst sÄ±nÄ±r (gÃ¼venlik payÄ±)
    
    # ADIM 4: Linear search - ASA hedefini karÅŸÄ±layan ilk agent sayÄ±sÄ±
    for agents in range(min_agents, max_agents + 1):
        asa = calculate_asa(agents, traffic, aht)
        if asa <= target_asa:
            return agents
    
    return max_agents


def find_agents_for_sl(calls, interval_min, aht, target_sl, target_seconds, tolerance, min_sl):
    """
    SL hedefi iÃ§in gereken agent sayÄ±sÄ±
    
    ADIM ADIM:
    1. Ã‡aÄŸrÄ± yoksa â†’ 0 agent dÃ¶ndÃ¼r
    2. Traffic hesapla
    3. Arama aralÄ±ÄŸÄ±nÄ± belirle
    4. HARD FLOOR: Ã–nce min_sl (%75) saÄŸlayan minimum agent bul
    5. Floor'dan baÅŸlayarak target_sl'ye (%80) en yakÄ±n olanÄ± seÃ§
    
    Parametreler:
        calls: Ã‡aÄŸrÄ± sayÄ±sÄ±
        interval_min: Ä°nterval sÃ¼resi (dakika)
        aht: Average Handle Time (saniye)
        target_sl: Hedef SL (Ã¶rn: 0.80)
        target_seconds: Hedef cevaplama sÃ¼resi (saniye)
        tolerance: Tolerans (Ã¶rn: 0.02 = Â±%2)
        min_sl: Minimum SL floor (Ã¶rn: 0.75 - asla altÄ±na dÃ¼ÅŸmez)
    
    DÃ¶ndÃ¼rÃ¼r:
        Gereken agent sayÄ±sÄ±
    """
    # ADIM 1: Ã‡aÄŸrÄ± kontrolÃ¼
    if calls == 0:
        return 0
    
    # ADIM 2: Traffic hesapla
    traffic = calculate_traffic(calls, interval_min, aht)
    if traffic == 0:
        return 0
    
    # ADIM 3: Arama aralÄ±ÄŸÄ±nÄ± belirle
    min_agents = math.ceil(traffic)
    max_agents = math.ceil(traffic * 2) + 10
    
    # ADIM 4: HARD FLOOR - min_sl (%75) saÄŸlayan minimum agent bul
    floor_agents = max_agents  # BaÅŸlangÄ±Ã§ deÄŸeri
    for agents in range(min_agents, max_agents + 1):
        sl = calculate_service_level(agents, traffic, aht, target_seconds)
        if sl >= min_sl:  # %75'i geÃ§en ilk deÄŸer
            floor_agents = agents
            break
    
    # ADIM 5: Floor'dan baÅŸlayarak target'a (%80) en yakÄ±n olanÄ± bul
    best_agent = floor_agents
    best_diff = 1.0
    
    for agents in range(floor_agents, max_agents + 1):
        sl = calculate_service_level(agents, traffic, aht, target_seconds)
        diff = abs(sl - target_sl)
        
        # Tolerans iÃ§inde ve ÅŸimdiye kadarki en iyi
        if diff <= tolerance and diff < best_diff:
            best_agent = agents
            best_diff = diff
            
            # Tam hedefte, daha aramaya gerek yok
            if diff < 0.001:
                break
    
    return best_agent


def find_optimal_agents(calls, config):
    """
    Hem ASA hem SL iÃ§in optimal agent sayÄ±sÄ±
    
    ADIM ADIM:
    1. Ã‡aÄŸrÄ± yoksa â†’ (0,0,0,0,0) dÃ¶ndÃ¼r
    2. ASA iÃ§in gereken agent sayÄ±sÄ±nÄ± bul
    3. SL iÃ§in gereken agent sayÄ±sÄ±nÄ± bul (min_sl floor ile)
    4. Ä°kisinden bÃ¼yÃ¼k olanÄ± seÃ§ (her iki hedefi de karÅŸÄ±lar)
    5. Shrinkage ekle (mola/izin payÄ±)
    6. Final metrikleri hesapla
    
    Parametreler:
        calls: Ã‡aÄŸrÄ± sayÄ±sÄ±
        config: KonfigÃ¼rasyon dictionary
    
    DÃ¶ndÃ¼rÃ¼r:
        (agents_final, agents_asa, agents_sl, final_asa, final_sl)
    """
    # ADIM 1: Ã‡aÄŸrÄ± kontrolÃ¼
    if calls == 0:
        return 0, 0, 0, 0, 0
    
    # ADIM 2: ASA iÃ§in agent sayÄ±sÄ±
    agents_asa = find_agents_for_asa(
        calls, 
        config['interval_minutes'],
        config['aht'],
        config['target_asa']
    )
    
    # ADIM 3: SL iÃ§in agent sayÄ±sÄ± (min_sl floor ile)
    agents_sl = find_agents_for_sl(
        calls,
        config['interval_minutes'],
        config['aht'],
        config['target_sl'],
        config['target_seconds'],
        config['sl_tolerance'],
        config['min_sl']  # Hard floor: %75
    )
    
    # ADIM 4: Ä°kisinden bÃ¼yÃ¼k olanÄ± seÃ§
    agents_raw = max(agents_asa, agents_sl)
    
    # ADIM 5: Shrinkage ekle
    agents_final = math.ceil(agents_raw / (1 - config['shrinkage']))
    
    # ADIM 6: Final metrikleri hesapla (kontrol amaÃ§lÄ±)
    traffic = calculate_traffic(calls, config['interval_minutes'], config['aht'])
    final_asa = calculate_asa(agents_raw, traffic, config['aht'])
    final_sl = calculate_service_level(agents_raw, traffic, config['aht'], config['target_seconds'])
    
    return agents_final, agents_asa, agents_sl, final_asa, final_sl


# ============================================================================
# BÃ–LÃœM 3: INTERVAL BAZLI Ä°HTÄ°YAÃ‡
# ============================================================================

def calculate_interval_requirements(df, config):
    """Her interval iÃ§in agent ihtiyacÄ±nÄ± hesapla (ASA + SL)"""
    results = []
    
    for idx, row in df.iterrows():
        date = row['date']
        time = row['time']
        
        # Time formatÄ±nÄ± dÃ¼zelt
        if hasattr(time, 'strftime'):
            time = time.strftime('%H:%M')
        elif not isinstance(time, str):
            time = str(time)
        
        calls_a = row['queue_a']
        calls_b = row['queue_b']
        
        # Her queue iÃ§in optimal agent bul
        agents_a, asa_agents_a, sl_agents_a, final_asa_a, final_sl_a = find_optimal_agents(calls_a, config)
        agents_b, asa_agents_b, sl_agents_b, final_asa_b, final_sl_b = find_optimal_agents(calls_b, config)
        
        results.append({
            'date': date,
            'time': time,
            'calls_a': calls_a,
            'calls_b': calls_b,
            'agents_a': agents_a,
            'agents_b': agents_b,
            'total_agents': agents_a + agents_b,
            'asa_a': round(final_asa_a, 1),
            'sl_a': round(final_sl_a * 100, 1),
            'asa_b': round(final_asa_b, 1),
            'sl_b': round(final_sl_b * 100, 1),
            'constraint_a': 'ASA' if asa_agents_a >= sl_agents_a else 'SL',
            'constraint_b': 'ASA' if asa_agents_b >= sl_agents_b else 'SL'
        })
    
    return pd.DataFrame(results)


# ============================================================================
# BÃ–LÃœM 4: GÃœNLÃœK ve AYLIK SERVICE LEVEL + COMPLIANCE
# ============================================================================

def calculate_daily_sl(interval_df):
    """GÃ¼nlÃ¼k Service Level (bilgi amaÃ§lÄ±)"""
    daily_results = []
    
    for date in sorted(interval_df['date'].unique()):
        day_data = interval_df[interval_df['date'] == date]
        
        total_calls_a = day_data['calls_a'].sum()
        total_calls_b = day_data['calls_b'].sum()
        
        # AÄŸÄ±rlÄ±klÄ± ortalama SL
        weighted_sl_a = (day_data['calls_a'] * day_data['sl_a']).sum() / total_calls_a if total_calls_a > 0 else 0
        weighted_sl_b = (day_data['calls_b'] * day_data['sl_b']).sum() / total_calls_b if total_calls_b > 0 else 0
        
        total_calls = total_calls_a + total_calls_b
        daily_sl = ((total_calls_a * weighted_sl_a) + (total_calls_b * weighted_sl_b)) / total_calls if total_calls > 0 else 0
        
        daily_results.append({
            'date': date,
            'total_calls': int(total_calls),
            'daily_sl_a': round(weighted_sl_a, 2),
            'daily_sl_b': round(weighted_sl_b, 2),
            'daily_sl_overall': round(daily_sl, 2)
        })
    
    return pd.DataFrame(daily_results)


def calculate_monthly_sl(interval_df):
    """AylÄ±k Service Level (ZORUNLU HEDEF)"""
    total_calls_a = interval_df['calls_a'].sum()
    total_calls_b = interval_df['calls_b'].sum()
    
    weighted_sl_a = (interval_df['calls_a'] * interval_df['sl_a']).sum() / total_calls_a if total_calls_a > 0 else 0
    weighted_sl_b = (interval_df['calls_b'] * interval_df['sl_b']).sum() / total_calls_b if total_calls_b > 0 else 0
    
    total_calls = total_calls_a + total_calls_b
    overall_sl = ((total_calls_a * weighted_sl_a) + (total_calls_b * weighted_sl_b)) / total_calls if total_calls > 0 else 0
    
    return {
        'total_calls_a': int(total_calls_a),
        'total_calls_b': int(total_calls_b),
        'total_calls': int(total_calls),
        'monthly_sl_a': round(weighted_sl_a, 2),
        'monthly_sl_b': round(weighted_sl_b, 2),
        'overall_sl': round(overall_sl, 2),
        'target_met': overall_sl >= CONFIG['target_sl'] * 100
    }


def calculate_compliance_rate(daily_sl_df, min_sl=75, max_sl=85):
    """
    GÃ¼nlerin kaÃ§ta kaÃ§Ä± hedef aralÄ±kta?
    TutarlÄ±lÄ±k Ã¶lÃ§Ã¼mÃ¼ - hem understaffing hem overstaffing'i yakalar
    
    ADIM ADIM:
    1. Toplam gÃ¼n sayÄ±sÄ±nÄ± al
    2. %75-85 aralÄ±ÄŸÄ±ndaki gÃ¼nleri filtrele
    3. Compliance rate hesapla
    4. AralÄ±k dÄ±ÅŸÄ± gÃ¼nleri listele
    
    Parametreler:
        daily_sl_df: GÃ¼nlÃ¼k SL dataframe'i
        min_sl: Alt sÄ±nÄ±r (default: 75)
        max_sl: Ãœst sÄ±nÄ±r (default: 85)
    
    DÃ¶ndÃ¼rÃ¼r:
        Compliance istatistikleri dictionary
    """
    # ADIM 1: Toplam gÃ¼n
    total_days = len(daily_sl_df)
    
    if total_days == 0:
        return None
    
    # ADIM 2: AralÄ±ktaki gÃ¼nleri filtrele
    compliant_days = daily_sl_df[
        (daily_sl_df['daily_sl_overall'] >= min_sl) & 
        (daily_sl_df['daily_sl_overall'] <= max_sl)
    ]
    
    compliant_count = len(compliant_days)
    
    # ADIM 3: Compliance rate
    compliance_rate = (compliant_count / total_days) * 100
    
    # ADIM 4: AralÄ±k dÄ±ÅŸÄ± gÃ¼nler
    below = daily_sl_df[daily_sl_df['daily_sl_overall'] < min_sl]
    above = daily_sl_df[daily_sl_df['daily_sl_overall'] > max_sl]
    
    return {
        'total_days': total_days,
        'compliant_days': compliant_count,
        'compliance_rate': round(compliance_rate, 1),
        'days_below': len(below),
        'days_above': len(above),
        'below_list': below[['date', 'daily_sl_overall']].to_dict('records'),
        'above_list': above[['date', 'daily_sl_overall']].to_dict('records'),
        'target_range': f'%{min_sl}-%{max_sl}'
    }


# ============================================================================
# BÃ–LÃœM 5: VARDÄ°YA YÃ–NETÄ°MÄ°
# ============================================================================

def load_shifts_from_excel(excel_path):
    """Vardiya Excel'den oku"""
    df = pd.read_excel(excel_path)
    
    required = ['shift', 'start', 'end']
    missing = [col for col in required if col not in df.columns]
    if missing:
        raise ValueError(f"âŒ Eksik kolonlar: {missing}")
    
    shifts = []
    for _, row in df.iterrows():
        shifts.append({
            'name': str(row['shift']),
            'start': str(row['start']) if not hasattr(row['start'], 'strftime') else row['start'].strftime('%H:%M'),
            'end': str(row['end']) if not hasattr(row['end'], 'strftime') else row['end'].strftime('%H:%M'),
            'company': str(row.get('company', ''))
        })
    
    return shifts


def time_to_minutes(time_str):
    """'07:30' â†’ 450 dakika"""
    if hasattr(time_str, 'strftime'):
        time_str = time_str.strftime('%H:%M')
    h, m = map(int, str(time_str).split(':'))
    return h * 60 + m


def is_time_in_shift(time_str, shift_start, shift_end):
    """Bir zaman vardiya iÃ§inde mi?"""
    time_min = time_to_minutes(time_str)
    start_min = time_to_minutes(shift_start)
    end_min = time_to_minutes(shift_end)
    
    # Gece vardiyasÄ± kontrolÃ¼ (Ã¶rn: 22:00 - 06:00)
    if end_min <= start_min:
        return time_min >= start_min or time_min < end_min
    else:
        return start_min <= time_min < end_min


def is_peak_hour(time_str):
    """Peak saat mi?"""
    hour = int(time_str.split(':')[0])
    return CONFIG['peak_hours']['start'] <= hour < CONFIG['peak_hours']['end']


def is_peak_shift(shift):
    """Peak vardiya mÄ±?"""
    shift_start_hour = int(shift['start'].split(':')[0])
    return CONFIG['peak_hours']['start'] <= shift_start_hour < CONFIG['peak_hours']['end']


def distribute_to_shifts(interval_df, shifts):
    """Vardiyalara peak Ã¶ncelikli daÄŸÄ±t"""
    results = []
    
    for idx, row in interval_df.iterrows():
        date = row['date']
        time = row['time']
        total_needed = row['total_agents']
        
        if total_needed == 0:
            continue
        
        is_peak = is_peak_hour(time)
        
        # Bu saatte Ã§alÄ±ÅŸan vardiyalarÄ± bul
        working_shifts = []
        for shift in shifts:
            if is_time_in_shift(time, shift['start'], shift['end']):
                is_peak_shift_flag = is_peak_shift(shift)
                weight = 1.5 if (is_peak and is_peak_shift_flag) else 1.0
                
                working_shifts.append({
                    'name': shift['name'],
                    'weight': weight
                })
        
        if len(working_shifts) == 0:
            continue
        
        # AÄŸÄ±rlÄ±klÄ± daÄŸÄ±tÄ±m
        total_weight = sum(ws['weight'] for ws in working_shifts)
        
        distribution = {}
        for ws in working_shifts:
            ratio = ws['weight'] / total_weight
            distribution[ws['name']] = total_needed * ratio
        
        # Yuvarlama dÃ¼zeltmesi
        current_total = sum(math.floor(v) for v in distribution.values())
        needed_diff = total_needed - current_total
        
        if needed_diff > 0:
            decimals = {k: v - math.floor(v) for k, v in distribution.items()}
            sorted_shifts = sorted(decimals.items(), key=lambda x: x[1], reverse=True)
            
            for i in range(needed_diff):
                shift_name = sorted_shifts[i % len(sorted_shifts)][0]
                distribution[shift_name] += 1
        
        for shift_name, agents in distribution.items():
            final_agents = math.floor(agents)
            if final_agents > 0:
                results.append({
                    'date': date,
                    'time': time,
                    'shift': shift_name,
                    'agents_needed': final_agents
                })
    
    return pd.DataFrame(results)


def aggregate_shifts(distribution_df, shifts):
    """Vardiya bazlÄ± MAX agent"""
    shift_results = []
    
    for date in sorted(distribution_df['date'].unique()):
        date_data = distribution_df[distribution_df['date'] == date]
        
        for shift in shifts:
            shift_data = date_data[date_data['shift'] == shift['name']]
            
            if len(shift_data) > 0:
                max_agents = math.ceil(shift_data['agents_needed'].max())
                
                shift_results.append({
                    'date': date,
                    'shift': shift['name'],
                    'start': shift['start'],
                    'end': shift['end'],
                    'company': shift.get('company', ''),
                    'agents': max_agents
                })
    
    return pd.DataFrame(shift_results)


# ============================================================================
# ANA FONKSÄ°YON
# ============================================================================

def calculate_complete_planning(df, shift_excel):
    """
    Komple kapasite planlamasÄ±
    ASA + SL (Saatlik ASA + GÃ¼nlÃ¼k Takip + AylÄ±k Hedef)
    Compliance Rate Takibi
    """
    
    print("=" * 80)
    print("KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V2")
    print("=" * 80)
    print(f"\nâš™ï¸ Hedefler:")
    print(f"   Saatlik: ASA â‰¤ {CONFIG['target_asa']} saniye")
    print(f"   Minimum SL: â‰¥ %{CONFIG['min_sl']*100} (hard floor)")
    print(f"   Hedef SL: %{CONFIG['target_sl']*100}")
    print(f"   AylÄ±k: SL â‰¥ %{CONFIG['target_sl']*100} (ZORUNLU)")
    print(f"   Compliance: %{CONFIG['compliance']['min_sl']}-%{CONFIG['compliance']['max_sl']} aralÄ±ÄŸÄ±")
    
    print(f"\nğŸ“‚ Vardiyalar: {shift_excel}")
    shifts = load_shifts_from_excel(shift_excel)
    print(f"âœ… {len(shifts)} vardiya yÃ¼klendi")
    
    print("\nâš™ï¸ BÃ–LÃœM 1: Interval bazlÄ± hesaplama...")
    interval_df = calculate_interval_requirements(df, CONFIG)
    print(f"âœ… {len(interval_df)} interval")
    print(f"   Peak agent: {interval_df['total_agents'].max()}")
    print(f"   Min SL: %{interval_df[['sl_a', 'sl_b']].min().min()}")
    
    print("\nâš™ï¸ BÃ–LÃœM 2: GÃ¼nlÃ¼k SL (takip)...")
    daily_sl_df = calculate_daily_sl(interval_df)
    
    avg_daily = daily_sl_df['daily_sl_overall'].mean()
    min_daily = daily_sl_df['daily_sl_overall'].min()
    max_daily = daily_sl_df['daily_sl_overall'].max()
    
    print(f"âœ… GÃ¼nlÃ¼k SL daÄŸÄ±lÄ±mÄ±:")
    print(f"   Ortalama: %{avg_daily:.1f}")
    print(f"   Min: %{min_daily:.1f} | Max: %{max_daily:.1f}")
    
    print("\nâš™ï¸ BÃ–LÃœM 3: Compliance Rate...")
    compliance = calculate_compliance_rate(
        daily_sl_df, 
        CONFIG['compliance']['min_sl'], 
        CONFIG['compliance']['max_sl']
    )
    print(f"âœ… Compliance Rate: %{compliance['compliance_rate']} ({compliance['compliant_days']}/{compliance['total_days']} gÃ¼n)")
    print(f"   Hedef aralÄ±k: {compliance['target_range']}")
    if compliance['days_below'] > 0:
        print(f"   âš ï¸ DÃ¼ÅŸÃ¼k gÃ¼nler ({compliance['days_below']}): {[x['date'] for x in compliance['below_list']]}")
    if compliance['days_above'] > 0:
        print(f"   âš ï¸ YÃ¼ksek gÃ¼nler ({compliance['days_above']}): {[x['date'] for x in compliance['above_list']]}")
    
    print("\nâš™ï¸ BÃ–LÃœM 4: AylÄ±k SL (ZORUNLU)...")
    monthly_sl = calculate_monthly_sl(interval_df)
    print(f"âœ… AylÄ±k SL: %{monthly_sl['overall_sl']:.1f}")
    print(f"   {'âœ… KARÅILANDI' if monthly_sl['target_met'] else 'âŒ KARÅILANMADI'}")
    
    print("\nâš™ï¸ BÃ–LÃœM 5: Vardiya daÄŸÄ±tÄ±mÄ±...")
    distribution_df = distribute_to_shifts(interval_df, shifts)
    vardiya_df = aggregate_shifts(distribution_df, shifts)
    print(f"âœ… {len(vardiya_df)} vardiya-gÃ¼n")
    
    print("\n" + "=" * 80)
    print("âœ… TAMAMLANDI!")
    print("=" * 80)
    
    return interval_df, vardiya_df, daily_sl_df, monthly_sl, compliance


# ============================================================================
# KULLANIM
# ============================================================================

if __name__ == '__main__':
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V2                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KULLANIM:

# SQL'den oku
import sqlalchemy
engine = sqlalchemy.create_engine('connection_string')
df = pd.read_sql('SELECT date, time, queue_a, queue_b FROM forecast', engine)

# VEYA Excel'den oku
df = pd.read_excel('cagri_tahminleri.xlsx')

# Hesapla
interval_df, vardiya_df, daily_sl_df, monthly_sl, compliance = calculate_complete_planning(
    df,
    shift_excel='vardiyalar.xlsx'
)

# Kaydet
interval_df.to_excel('sonuc_interval.xlsx', index=False)
vardiya_df.to_excel('sonuc_vardiya.xlsx', index=False)
daily_sl_df.to_excel('sonuc_gunluk_sl.xlsx', index=False)

print(f"AylÄ±k SL: %{monthly_sl['overall_sl']}")
print(f"Compliance Rate: %{compliance['compliance_rate']}")
""")
