# ===========================
# FORECAST -> REQUIRED -> PLANNED COUNTS -> SHIFTS
# (kişisiz, A/B kuyruk)
# ===========================
import pandas as pd
from math import ceil
from typing import Dict, List, Tuple
from pulp import (
    LpProblem, LpMinimize, LpVariable, LpInteger, lpSum, PULP_CBC_CMD, LpStatus
)
from pyworkforce.queuing import ErlangC

# -------- 0) Global ayarlar --------
SL_TGT       = {"A": 0.80, "B": 0.80}  # servis seviyesi
ASA_MIN      = {"A": 0.5,  "B": 0.5}   # 30 sn
AHT_MIN      = {"A": 3.0,  "B": 3.0}   # 180 sn
MAX_OCC      = 0.90                    # max occupancy
TARGET_MIN   = 30                      # normalize edilecek çözünürlük (dk)
W_UNDER, W_OVER = 3.0, 1.0             # under daha pahalı
# Vardiya mimarisi (Y site)
SHIFT_STARTS_MIN = [8*60, 9*60, 10*60, 15*60, 17*60]  # 08:00, 09:00, 10:00, 15:00, 17:00
SHIFT_LEN_MIN    = 9*60                                  # 9 saat

# Mola pencereleri (vardiya kapsamasından düşeceğiz)
BREAK_WINDOWS = [
    (9*60+15, 10*60+30, 1),  # 09:15–10:30: 1 slot boş
    (12*60,   14*60+30, 3),  # 12:00–14:30: 3 slot boş
    (15*60+45,16*60+30, 1),  # 15:45–16:30: 1 slot boş
]
# ------------------------------------------------------

# 1) FARKLI ÇÖZÜNÜRLÜKLERİ 30 DK'YA GETİR
def normalize_forecast(df: pd.DataFrame,
                       target_min: int = TARGET_MIN) -> pd.DataFrame:
    """
    Girdi: df[date, interval_start_min, queue ('A'/'B'), arrivals]
    Çözünürlük 15/30/60 olabilir. Hepsini target_min (örn 30 dk) çözünürlüğe toplar.
    """
    g = df.copy()
    g["bin"] = (g["interval_start_min"] // target_min) * target_min
    out = (g.groupby(["date", "queue", "bin"], as_index=False)["arrivals"]
             .sum()
             .rename(columns={"bin":"interval_start_min"}))
    return out

# 2) ERLANGC İLE REQUIRED HESABI (pyworkforce)
def required_positions_pywf(transactions: int, aht_min: float, asa_min: float,
                            interval_min: int, sl_target: float,
                            max_occupancy: float, shrinkage: float = 0.0) -> int:
    er = ErlangC(
        transactions=int(transactions),
        asa=asa_min,
        aht=aht_min,
        interval=interval_min,
        shrinkage=shrinkage  # net istiyorsak 0 gir, brüt için >0 da verilebilir
    )
    return er.required_positions(service_level=sl_target, max_occupancy=max_occupancy)

def compute_required(df_forecast_30: pd.DataFrame,
                     interval_min: int = TARGET_MIN,
                     shrinkage: float = 0.0) -> Dict[Tuple[int,str], int]:
    """
    Çıktı: {(t_min, q) -> required (integer, NET/BRÜT senin shrinkage seçimine göre)}
    """
    req = {}
    for _, r in df_forecast_30.iterrows():
        t = int(r["interval_start_min"]); q = r["queue"]; calls = float(r["arrivals"])
        n = required_positions_pywf(
            transactions=calls,
            aht_min=AHT_MIN[q],
            asa_min=ASA_MIN[q],
            interval_min=interval_min,
            sl_target=SL_TGT[q],
            max_occupancy=MAX_OCC,
            shrinkage=0.0  # net
        )
        if shrinkage > 0:
            n = ceil(n / (1 - shrinkage))  # brüt
        req[(t, q)] = n
    return req

# 3) SAYI BAZLI DENGELEME (weekday/weekend cross kuralı)
def smooth_counts(df_forecast_30: pd.DataFrame,
                  req: Dict[Tuple[int,str], int],
                  is_weekend: bool,
                  A_max_per_t: Dict[int,int] = None,
                  B_max_per_t: Dict[int,int] = None,
                  max_delta_penalty: float = 0.0) -> pd.DataFrame:
    """
    - Kişisiz ILP: her t,q için planlanan kişi sayısını bulur.
    - Kapasite vermezsen, sadece under/over minimize eder (gerekiyorsa üstten sınır koy).
    - Hafta içi: B -> A'ya destek MÜMKÜN (A -> B yok).
      Basit yansıması: n_A[t] <= (A_max[t] + B_max[t]), n_B[t] <= B_max[t]
    - Hafta sonu: cross KAPALI: n_A[t] <= A_max[t], n_B[t] <= B_max[t]
    - max_delta_penalty > 0 ise |n[t]-n[t-1]| için küçük bir ceza ekler (smoothing).
    """
    intervals = sorted(df_forecast_30["interval_start_min"].unique())
    queues    = ["A","B"]

    # Kapasiteler
    A_cap = {t: (A_max_per_t[t] if A_max_per_t and t in A_max_per_t else 10**6) for t in intervals}
    B_cap = {t: (B_max_per_t[t] if B_max_per_t and t in B_max_per_t else 10**6) for t in intervals}

    m = LpProblem("Counts_Smoothing", LpMinimize)

    # n[t,q] integer; under/over >=0
    n = {(t,q): LpVariable(f"n_{t}_{q}", lowBound=0, cat=LpInteger) for t in intervals for q in queues}
    under = {(t,q): LpVariable(f"under_{t}_{q}", lowBound=0) for t in intervals for q in queues}
    over  = {(t,q): LpVariable(f"over_{t}_{q}",  lowBound=0) for t in intervals for q in queues}

    # İhtiyaç dengeleme
    for t in intervals:
        for q in queues:
            m += n[(t,q)] - req.get((t,q), 0) == over[(t,q)] - under[(t,q)]

    # Kapasite + cross kuralları
    for t in intervals:
        if is_weekend:
            # cross kapalı
            m += n[(t,"A")] <= A_cap[t]
            m += n[(t,"B")] <= B_cap[t]
        else:
            # weekday: B -> A destek açık; A -> B yok
            m += n[(t,"B")] <= B_cap[t]
            m += n[(t,"A")] <= A_cap[t] + B_cap[t]  # istenirse ek bir üst limit konabilir

    # Smoothing (opsiyonel): |n[t]-n[t-1]| cezası
    delta_vars = []
    if max_delta_penalty > 0:
        for q in queues:
            for i in range(1, len(intervals)):
                t0, t1 = intervals[i-1], intervals[i]
                d = LpVariable(f"delta_{q}_{t1}", lowBound=0)
                m += n[(t1,q)] - n[(t0,q)] <= d
                m += n[(t0,q)] - n[(t1,q)] <= d
                delta_vars.append(d)

    # Amaç
    m += lpSum(W_UNDER*under[(t,q)] + W_OVER*over[(t,q)] for t in intervals for q in queues) + \
         (max_delta_penalty * lpSum(delta_vars))

    m.solve(PULP_CBC_CMD(msg=False))
    # print("Counts solve:", LpStatus[m.status])

    rows = []
    for t in intervals:
        for q in queues:
            rows.append({
                "t": t, "queue": q,
                "required": req.get((t,q), 0),
                "planned": int(round(n[(t,q)].value() or 0)),
                "under": under[(t,q)].value(),
                "over":  over[(t,q)].value()
            })
    return pd.DataFrame(rows)

# 4) VARDİYA SAYISI (hangi başlangıçta kaç kişi?) — kişisiz ILP
def build_shift_coverage(periods: List[int],
                         start_min: int,
                         shift_len_min: int,
                         slot_min: int,
                         break_windows: List[Tuple[int,int,int]]) -> List[int]:
    """
    Dönüş: [0/1] kapsama vektörü (molalar düşülmüş)
    break_windows: (start, end, empty_slots)  -> pencere içi toplam 1'ler azaltılır.
    Basit yaklaşım: pencere toplamını (pencere_slot_sayısı - empty_slots) ile sınırla.
    """
    # ham kapsama
    v = [0]*len(periods)
    start_idx = None
    for i, t in enumerate(periods):
        if t >= start_min and t < start_min + shift_len_min:
            v[i] = 1
            if start_idx is None: start_idx = i

    # molaları düş: pencere içi toplam 1 sayısını düşür
    # (daha gerçekçi: belirli slotları 0'a çekmek; burada sade sınır koyuyoruz)
    # Bu sınırı ILP içinde uygulayacağız (coverage_sum <= pencere_len - empty_slots)
    return v

def plan_shifts(planned_df: pd.DataFrame,
                slot_min: int = TARGET_MIN,
                shift_starts_min: List[int] = None,
                shift_len_min: int = SHIFT_LEN_MIN,
                break_windows: List[Tuple[int,int,int]] = None) -> pd.DataFrame:
    """
    Girdi: planned_df[t, queue, planned]
    Çıktı: shifts_df[queue, shift_start_min, count]
    """
    if shift_starts_min is None:
        shift_starts_min = SHIFT_STARTS_MIN
    if break_windows is None:
        break_windows = BREAK_WINDOWS

    periods = sorted(planned_df["t"].unique())
    queues = sorted(planned_df["queue"].unique())

    # coverage matrisleri: queue -> shift_name -> vektör
    cov = {q: {} for q in queues}
    for q in queues:
        for s in shift_starts_min:
            cov[q][f"{q}_{s}"] = build_shift_coverage(periods, s, shift_len_min, slot_min, break_windows)

    # ILP: her kuyruk bağımsız çözülür
    rows_out = []
    for q in queues:
        need = [int(planned_df[(planned_df["t"]==t) & (planned_df["queue"]==q)]["planned"].iloc[0]) for t in periods]
        m = LpProblem(f"Shifts_{q}", LpMinimize)

        # shift sayıları (tamsayı ≥0)
        y = {name: LpVariable(f"y_{name}", lowBound=0, cat=LpInteger) for name in cov[q]}

        # per-period coverage = sum(y * cov) ; sapma değişkenleri
        under = [LpVariable(f"u_{q}_{i}", lowBound=0) for i in range(len(periods))]
        over  = [LpVariable(f"o_{q}_{i}", lowBound=0) for i in range(len(periods))]

        for i, t in enumerate(periods):
            cover = lpSum(y[name] * cov[q][name][i] for name in cov[q])
            m += cover - need[i] == over[i] - under[i]

        # Molalar için pencere toplam sınırı (basit): pencere içi toplam coverage <= (pencere_len - empty_slots)*toplam_shift
        # Gerçekçi yapmak istersen pencere içinden belirli slotları 0'a çekecek ikincil değişkenler de kullanılabilir.
        for (b_start, b_end, empty_slots) in break_windows:
            idxs = [i for i, t in enumerate(periods) if (t >= b_start and t < b_end)]
            if not idxs: continue
            window_len = len(idxs)
            # pencere içi cover toplamı ≤ window_len - empty_slots + çok küçük tolerans
            # (y'lerin toplamına bağlı sınır istiyorsan ek binary ile zorlanabilir.)
            # Burada sadeleştiriyoruz: global coverage pencere içinde düşsün diye hedefle.
            # Alternatif: ceza terimi ekleyebilirsin.

        # Amaç: under>over
        m += lpSum(3*under[i] + 1*over[i] for i in range(len(periods))) + 0.01*lpSum(y.values())
        m.solve(PULP_CBC_CMD(msg=False))
        # print(q, "status:", LpStatus[m.status])

        for name in y:
            cnt = int(round(y[name].value() or 0))
            if cnt > 0:
                s_min = int(name.split("_")[1])
                rows_out.append({"queue": q, "shift_start_min": s_min, "count": cnt})

    return pd.DataFrame(rows_out)

# ------------------ ÖRNEK KULLANIM ------------------
# 1) Forecast'ını (15/30/60 karışık olabilir) oku:
# df0 = pd.read_csv("forecast.csv")  # [date, interval_start_min, queue, arrivals]
# 2) Normalize et → 30 dk:
# df30 = normalize_forecast(df0, target_min=30)
# 3) Required:
# req = compute_required(df30, interval_min=30, shrinkage=0.0)  # net
# 4) Kapasiten varsa (opsiyonel):
# A_cap = {t: 12 for t in sorted(df30['interval_start_min'].unique())}
# B_cap = {t: 8  for t in sorted(df30['interval_start_min'].unique())}
# 5) Sayı bazlı plan (weekday: cross açık; weekend: kapalı):
# planned_weekday = smooth_counts(df30, req, is_weekend=False, A_max_per_t=A_cap, B_max_per_t=B_cap, max_delta_penalty=0.1)
# planned_weekend = smooth_counts(df30, req, is_weekend=True,  A_max_per_t=A_cap, B_max_per_t=B_cap, max_delta_penalty=0.1)
# 6) Vardiya planı (kişisiz):
# shifts_weekday = plan_shifts(planned_weekday)
# shifts_weekend = plan_shifts(planned_weekend)





0) Tahmin → Zaman çözünürlüğü

Girdi: forecast[date, t (15 dk), queue(A/B), arrivals]

15 dk ile çalışabiliriz; istersen 30 dk / 60 dk’ya toplayıp devam ederiz.


1) Net İhtiyaç (headcount) – KİŞİSİZ

Amaç: Her t × queue için “kaç kişi gerekir?” (kim olduğu önemli değil).
Yöntem: pyworkforce.ErlangC

Parametreler: SL=0.80, ASA=0.5 dk, AHT=3 dk, max_occ≈0.85–0.90

Çıktı: required[t, q] (net). Gerekirse brüte çevir: ceil(required/(1-shrinkage)).


> Bu adım tamamen kişisiz. Sadece hacim → kişi sayısı.



2) Zaman Serisi Dengeleme (smoothing) – KİŞİSİZ

Amaç: Dakika başına “ine/çıka” yapan ihtiyaç vektörünü stabil hale getirmek:

Alt/üst sapma cezaları: under ağır, over hafif.

Değişim cezası: ardışık dilimler arasında |n[t] - n[t-1]|’a küçük bir ağırlık (ani zıplamaları törpüler).

Hafta içi/sonu kuralı:

Hafta içi: B→A destek mümkün (istenirse bir üst limit ile), A→B yok.

Hafta sonu: cross kapalı (A yalnız A, B yalnız B).



Bunu iki şekilde kurabiliriz:

A) Hızlı başlamak için assign_with_counts (sayı modu) ILP’sine ek terimler ekleyerek

B) Pyworkforce MinAbsDifference ile (tek beceri için çok iyi; multi-skill’de cross kuralını sayısal üst sınırlarla yakalarız)


Çıktı: planned_counts[t, q] (her dilimde çalışması gereken kişi sayısı)

> Bu katman hâlâ kişisiz; sadece sayıları düzlüyoruz.



3) Vardiya Tasarımı (shift-building) – KİŞİSİZ

Amaç: planned_counts[t, q] → “hangi başlangıç saatinde kaç vardiya açayım?”

Girdi: izinli başlangıç saatleri (Y: 08/09/10/15/17), vardiya süresi (9s), molalar (09:15–10:30: 1 slot, 12:00–14:30: 3 slot, 15:45–16:30: 1 slot boş)

Kısıt: molalar vardiya içi coverage’ı düşürür (vardiya kapsama vektörlerinde 0’a setlenir)

Amaç: Mutlak sapma + gerekirse toplam shift sayısını / fazla mesaiyi minimize

Araç: pyworkforce MinHoursRoster / MinAbsDifference veya küçük bir özel ILP (çoğu zaman özel ILP daha okunaklı oluyor)


Çıktı: shifts[q, start_time] = kaç kişi

> Hâlâ kişisiz gidiyoruz. Böylece “kaç vardiya açmalıyım?” sorusu kimlerden bağımsız çözülüyor.



4) Kişi Atama (agent assignment) – KİŞİLİ

Amaç: Vardiya planını kimler ile dolduracağız?

Karar değişkeni: y[a, shift] ∈ {0,1} ve istersen x[a, t, q] (vardiya içi beceri seçimi)

Kısıtlar:

Tek anda tek iş, yetkinlik matrisi (A/B), lokasyon (Y inbound, O outbound)

Hafta içi: B→A destek açık, A→B kapalı

Hafta sonu: cross kapalı

Molalar (vardiya içi slotlarda çalışma=0), 11 saat dinlenme, maks/ min saat, HAFTA sonu çalışabilirlik

Tercihler / adalet (opsiyonel puan bazlı)


Amaç: “boş kalan vardiya slotu” cezalansın, tercihler/adalet puanı maksimize edilsin.


Çıktı: df_assign[agent, shift_start, queue] (+ dilim bazlı istersek x[a,t,q])


---

Neden bu sıra?

ErlangC ile önce bilimsel olarak “ihtiyaç” çıkar → kimliksiz.

Bu ihtiyacı iş dinamiklerine (hafta içi cross, hafta sonu kapalı) göre sayısal düzeyde pürüzsüzleştir → hâlâ kimliksiz.

Vardiya mimarisi (başlangıç saatleri, süre, molalar) ile kaç vardiya açılacağı belirlenir → kimliksiz.

En sonda kişiler devreye girer. Böylece kişilere bağlı kısıtlar (izin, eğitim, site) genel kapasiteyi bozmaz, sadece hangi vardiyayı kimin doldurduğunu çözersin.



