from pulp import *
import pandas as pd
from pyworkforce.queuing import ErlangC
import numpy as np
import math

# ----------------------------------------------------
# 1. VERİ TANIMLAMA
# ----------------------------------------------------

# Çalışan Tanımları
A_CALISANLARI = [f'A{i}' for i in range(1, 10)] # 9 A-Uzmanı
B_CALISANLARI = [f'B{i}' for i in range(1, 7)]  # 6 B-Uzmanı
TUM_CALISANLAR = A_CALISANLARI + B_CALISANLARI

# Zaman ve Vardiya Tanımları
VARDİYALAR = ['Sabah', 'Öğle', 'Gece'] # Her biri 8 saat sürer
GUNLER_HAFTA = ['Pzt', 'Sal', 'Çar', 'Per', 'Cum', 'Cmt', 'Paz']
HAFTA_SAYISI = 4
HAFTA_SONU = ['Cmt', 'Paz']

# Erlang C Parametreleri
SERVICE_LEVEL_TARGET = 0.85  # %85 çağrının 20 saniyede cevaplanması
MAX_DELAY = 20               # Saniye
AHT_SECONDS = 300            # Ortalama işlem süresi: 300 saniye (5 dakika)
HOURLY_INTERVAL_SECONDS = 3600 # 1 Saatlik zaman dilimi (Erlang C için)
HOURS_PER_SHIFT = 8          # Bir vardiyadaki saat dilimi sayısı (8 saatlik vardiya)

# Saatlik Çağrı Verisi (Varsayım: Vardiya başına gelen çağrıların 8 saate eşit dağılımı)
SHIFT_CALLS = {
    'A': { # Vardiya Başına Toplam Çağrı Sayısı (Eski veriniz)
        'Sabah': {'Pzt': 80, 'Sal': 85, 'Çar': 90, 'Per': 95, 'Cum': 120, 'Cmt': 150, 'Paz': 140},
        'Öğle':  {'Pzt': 140, 'Sal': 150, 'Çar': 160, 'Per': 170, 'Cum': 190, 'Cmt': 220, 'Paz': 200},
        'Gece':  {'Pzt': 50, 'Sal': 55, 'Çar': 60, 'Per': 65, 'Cum': 70, 'Cmt': 75, 'Paz': 65}
    },
    'B': { # B Kuyruğu Trafiği
        'Sabah': {'Pzt': 40, 'Sal': 45, 'Çar': 30, 'Per': 35, 'Cum': 45, 'Cmt': 20, 'Paz': 15},
        'Öğle':  {'Pzt': 60, 'Sal': 65, 'Çar': 70, 'Per': 75, 'Cum': 80, 'Cmt': 50, 'Paz': 45},
        'Gece':  {'Pzt': 5, 'Sal': 5, 'Çar': 5, 'Per': 5, 'Cum': 10, 'Cmt': 5, 'Paz': 5}
    }
}

# ----------------------------------------------------
# 2. AŞAMA: SAATLİK ERLANG C İLE DİNAMİK TALEP HESAPLAMA
# ----------------------------------------------------

erlang = ErlangC(
    transactions=0, # Dinamik olarak ayarlanacak
    aht=AHT_SECONDS, 
    interval=HOURLY_INTERVAL_SECONDS, # 1 saatlik aralık
    service_level=SERVICE_LEVEL_TARGET, 
    max_delay=MAX_DELAY,
    max_occupancy=0.85 
)

MIN_DEMAND_PER_SHIFT = {'A': {}, 'B': {}}

for queue in ['A', 'B']:
    MIN_DEMAND_PER_SHIFT[queue] = {v: {} for v in VARDİYALAR}
    for v in VARDİYALAR:
        for g in GUNLER_HAFTA:
            total_shift_calls = SHIFT_CALLS[queue][v][g]
            
            # Her saatlik dilime düşen ortalama çağrı adedi
            # Not: Gerçek modelde, bu verinin her saat için ayrı gelmesi gerekir.
            hourly_calls_per_slot = total_shift_calls / HOURS_PER_SHIFT
            
            if hourly_calls_per_slot == 0:
                max_required_agents = 0
            else:
                # 8 saatlik vardiyadaki her 1 saatlik dilim için hesaplama yaparız.
                required_agents_list = []
                for hour in range(HOURS_PER_SHIFT):
                    # Tüm saatlerde eşit çağrı geldiği varsayımıyla hesapla
                    
                    # Erlang C, işlemleri integer bekler, çağrıları yuvarlayalım
                    calls_in_slot = math.ceil(hourly_calls_per_slot)
                    
                    results = erlang.required_agents(transactions=calls_in_slot)
                    
                    # İhtiyaç duyulan personel sayısı her zaman yukarı yuvarlanır
                    required_agents = int(np.ceil(results['required_agents']))
                    required_agents_list.append(required_agents)

                # PuLP (Vardiya) modeline girdi olarak, o vardiyanın EN YÜKSEK saatlik personel ihtiyacını almalıyız.
                max_required_agents = max(required_agents_list)
            
            MIN_DEMAND_PER_SHIFT[queue][v][g] = max_required_agents

# Kontrol: Hesaplanan talebin bir kısmını yazdır
print("\n--- Hesaplanan Maksimum Personel Talebi (Erlang C Saatlik Bazlı) ---")
print(MIN_DEMAND_PER_SHIFT['A']['Sabah']) 
print("---------------------------------------------------------------------")

# ----------------------------------------------------
# 3. AŞAMA: PuLP OPTİMİZASYON MODELİNİ OLUŞTURMA
# ----------------------------------------------------

# ... (KARAR DEĞİŞKENLERİ, AMAÇ FONKSİYONU ve KISITLAR, sadece Kısıt 2'de MIN_DEMAND_PER_SHIFT kullanılarak devam eder)

model = LpProblem("Erlang_C_Saatlik_Rostering_Optimizasyonu", LpMinimize)

# KARAR DEĞİŞKENLERİ
X = LpVariable.dicts("Atama", (TUM_CALISANLAR, VARDİYALAR, range(1, HAFTA_SAYISI + 1), GUNLER_HAFTA), cat=LpBinary)
Y = LpVariable.dicts("HS_Calisma", (TUM_CALISANLAR, range(1, HAFTA_SAYISI + 1)), cat=LpBinary)

# AMAÇ FONKSİYONU
model += lpSum([X[c][v][h][g] for c in TUM_CALISANLAR for v in VARDİYALAR for h in range(1, HAFTA_SAYISI + 1) for g in GUNLER_HAFTA]), "Toplam_Atanan_Vardiya_Sayisi"

# KISITLAR 
# Kısıt 1: Bireysel Kapasite (Aynı kalır)
for c in TUM_CALISANLAR:
    for h in range(1, HAFTA_SAYISI + 1):
        for g in GUNLER_HAFTA:
            model += lpSum([X[c][v][h][g] for v in VARDİYALAR]) <= 1, f"Kisit_Tek_Vardiya_{c}_{h}_{g}"

# Kısıt 2: Dinamik Erlang C Talep Kısıtı (Yeni talep kaynağı kullanıldı)
for v in VARDİYALAR:
    for h in range(1, HAFTA_SAYISI + 1):
        for g in GUNLER_HAFTA:
            
            A_talep = MIN_DEMAND_PER_SHIFT['A'][v][g] # Saatlik Max Talep
            B_talep = MIN_DEMAND_PER_SHIFT['B'][v][g] 
            
            # B Kuyruğu Kısıtı
            model += lpSum([X[c][v][h][g] for c in B_CALISANLARI]) >= B_talep, f"Kisit_Talep_B_{v}_{h}_{g}"
            
            # A Kuyruğu Kısıtı
            if g in HAFTA_SONU:
                model += lpSum([X[c][v][h][g] for c in A_CALISANLARI]) >= A_talep, f"Kisit_Talep_A_HS_{v}_{h}_{g}"
            else:
                model += lpSum([X[c][v][h][g] for c in TUM_CALISANLAR]) >= A_talep, f"Kisit_Talep_A_HI_{v}_{h}_{g}"

# Kısıt 3: Maksimum Ardışık Vardiya (Aynı kalır)
for c in TUM_CALISANLAR:
    for h in range(1, HAFTA_SAYISI + 1):
        for i in range(len(GUNLER_HAFTA) - 2): 
            g1, g2, g3 = GUNLER_HAFTA[i], GUNLER_HAFTA[i+1], GUNLER_HAFTA[i+2]
            model += lpSum([X[c][v][h][g1] for v in VARDİYALAR]) + lpSum([X[c][v][h][g2] for v in VARDİYALAR]) + lpSum([X[c][v][h][g3] for v in VARDİYALAR]) <= 2, f"Kisit_Max_2_Gun_Calisma_{c}_{h}_{g1}"

# Kısıt 4: Aylık Haftasonu Kısıtı (KeyError düzeltmesi dahil)
for c in TUM_CALISANLAR:
    for h in range(1, HAFTA_SAYISI + 1):
        haftasonu_vardiya_sayisi = lpSum([X[c][v][h][g] for v in VARDİYALAR for g in HAFTA_SONU])
        # KEY ERROR DÜZELTMESİ: Y[(c, h)]
        model += haftasonu_vardiya_sayisi <= len(HAFTA_SONU) * Y[(c, h)], f"Kisit_HS_Calisma_Yukari_{c}_{h}"
        
    model += lpSum([Y[(c, h)] for h in range(1, HAFTA_SAYISI + 1)]) <= HAFTA_SAYISI - 1, f"Kisit_Min_1_HS_Izin_{c}"

# Kısıt 5: Maksimum 6 Gün Çalışma (Aynı kalır)
for c in TUM_CALISANLAR:
    for h in range(1, HAFTA_SAYISI + 1):
        haftalik_vardiya_sayisi = lpSum([X[c][v][h][g] for v in VARDİYALAR for g in GUNLER_HAFTA])
        model += haftalik_vardiya_sayisi <= 6, f"Kisit_Maks_6_Gun_{c}_{h}"


# ----------------------------------------------------
# 4. AŞAMA: MODELİ ÇÖZME VE SONUÇLARI GÖRÜNTÜLEME
# ----------------------------------------------------

print("\nModel Çözülüyor...")
model.solve()

# ATTRIBUTE ERROR DÜZELTMESİ: model.status == 1 kontrolü
print(f"\nÇözüm Durumu: {LpStatus[model.status]}")

if model.status == 1: 
    print(f"Minimum Toplam Atanan Vardiya Sayısı (4 Haftalık): {value(model.objective):.0f}")
    print("Çözüm Başarılı! Atamalar yapılmıştır.")
    # ... (Geri kalan sonuç yazdırma kodu buraya devam etmeli)
    
else:
    print(f"Optimal bir çözüm bulunamadı. Çözüm durumu: {LpStatus[model.status]}")
