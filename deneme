â€œâ€â€
KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V4
KatmanlÄ± Hesaplama + YardÄ±mlaÅŸma MantÄ±ÄŸÄ± + Vardiya Optimizasyonu

Ã–zellikler:

- 3 kuyruk desteÄŸi (A, B, C)
- Hafta iÃ§i/sonu ayrÄ±mÄ± (weekday_flg)
- B ve C agentlarÄ± hafta iÃ§i Aâ€™ya yardÄ±m eder
- KatmanlÄ± raporlama (Base, FazlalÄ±k, Final)
- pyworkforce ile vardiya optimizasyonu

Kurulum:
pip install pyworkforce pandas openpyxl
â€œâ€â€

import pandas as pd
import math
from datetime import datetime
from pyworkforce.scheduling import MinRequiredResources

# ============================================================================

# KONFÄ°GURASYON

# ============================================================================

CONFIG = {
# Erlang C parametreleri
â€˜ahtâ€™: 188,                  # Average Handle Time - saniye
â€˜target_asaâ€™: 30,            # Hedef ASA - saniye
â€˜target_slâ€™: 0.80,           # Hedef Service Level - %80
â€˜target_secondsâ€™: 30,        # SL iÃ§in hedef sÃ¼re
â€˜shrinkageâ€™: 0.10,           # Mola/izin payÄ± - %10
â€˜interval_minutesâ€™: 60,      # Ä°nterval - dakika

```
# Mevcut kadro
'staff': {
    'queue_a': 800,
    'queue_b': 50,
    'queue_c': 100
},

# YardÄ±mlaÅŸma kurallarÄ±
'help_rules': {
    'b_helps_a': True,       # B, A'ya yardÄ±m edebilir
    'c_helps_a': True,       # C, A'ya yardÄ±m edebilir
    'weekday_only': True     # Sadece hafta iÃ§i yardÄ±mlaÅŸma
},

# Optimizasyon
'optimization': {
    'max_period_concurrency': 1500,
    'max_shift_concurrency': 800,
    'max_search_time': 300.0
},

# Compliance
'compliance': {
    'min_sl': 75,
    'max_sl': 85
}
```

}

# ============================================================================

# BÃ–LÃœM 1: ERLANG C TEMELLERÄ°

# ============================================================================

def erlang_c(agents, traffic):
â€œâ€â€œErlang C: Kuyrukta bekleme olasÄ±lÄ±ÄŸÄ±â€â€â€
if agents <= traffic or agents == 0:
return 1.0

```
erlang_b = traffic / agents
for i in range(2, int(agents) + 1):
    erlang_b = (traffic * erlang_b) / (i + traffic * erlang_b)

erlang_c_val = erlang_b / (1 - (traffic / agents) * (1 - erlang_b))
return min(erlang_c_val, 1.0)
```

def calculate_asa(agents, traffic, aht):
â€œâ€â€œASA hesapla - saniyeâ€â€â€
if agents <= traffic or agents == 0:
return 999

```
ec = erlang_c(agents, traffic)
asa = (ec * (aht / 60)) / (agents - traffic) * 60
return asa
```

def calculate_service_level(agents, traffic, aht, target_seconds):
â€œâ€â€œService Level hesaplaâ€â€â€
if agents <= traffic or agents == 0:
return 0.0

```
ec = erlang_c(agents, traffic)
exp_term = math.exp(-(agents - traffic) * (target_seconds / aht))
sl = 1 - (ec * exp_term)
return max(0, min(1, sl))
```

def calculate_traffic(calls, interval_min, aht):
â€œâ€â€œTraffic (Erlang) hesaplaâ€â€â€
if calls == 0:
return 0
return (calls * (aht / 60)) / interval_min

def find_agents_for_asa(calls, interval_min, aht, target_asa):
â€œâ€â€œASA hedefi iÃ§in gereken agent sayÄ±sÄ±â€â€â€
if calls == 0:
return 0

```
traffic = calculate_traffic(calls, interval_min, aht)
if traffic == 0:
    return 0

min_agents = math.ceil(traffic)
max_agents = math.ceil(traffic * 2) + 5

for agents in range(min_agents, max_agents + 1):
    asa = calculate_asa(agents, traffic, aht)
    if asa <= target_asa:
        return agents

return max_agents
```

def find_optimal_agents(calls, config):
â€œâ€â€œTek kuyruk iÃ§in optimal agent (shrinkage dahil)â€â€â€
if calls == 0:
return 0, 0, 0

```
agents_raw = find_agents_for_asa(
    calls,
    config['interval_minutes'],
    config['aht'],
    config['target_asa']
)

agents_final = math.ceil(agents_raw / (1 - config['shrinkage']))

traffic = calculate_traffic(calls, config['interval_minutes'], config['aht'])
final_asa = calculate_asa(agents_raw, traffic, config['aht']) if agents_raw > 0 else 0
final_sl = calculate_service_level(agents_raw, traffic, config['aht'], config['target_seconds']) if agents_raw > 0 else 0

return agents_final, final_asa, final_sl
```

# ============================================================================

# BÃ–LÃœM 2: BASE SENARYO - HER KUYRUK Ä°Ã‡Ä°N MÄ°NÄ°MUM Ä°HTÄ°YAÃ‡

# ============================================================================

def calculate_base_requirements(df, config):
â€œâ€â€
ADIM 1: Her kuyruk iÃ§in ayrÄ± ayrÄ± minimum agent ihtiyacÄ±
YardÄ±mlaÅŸma YOK - saf ihtiyaÃ§
â€œâ€â€
results = []

```
for idx, row in df.iterrows():
    date = row['date']
    time = row['time']
    weekday_flg = row.get('weekday_flg', 1)  # Default hafta iÃ§i
    
    # Time formatÄ±nÄ± dÃ¼zelt
    if hasattr(time, 'strftime'):
        time = time.strftime('%H:%M')
    elif not isinstance(time, str):
        time = str(time)
    
    # Her kuyruk iÃ§in Ã§aÄŸrÄ± sayÄ±sÄ±
    calls_a = row.get('queue_a', 0)
    calls_b = row.get('queue_b', 0)
    calls_c = row.get('queue_c', 0)
    
    # Her kuyruk iÃ§in base ihtiyaÃ§ hesapla
    agents_a, asa_a, sl_a = find_optimal_agents(calls_a, config)
    agents_b, asa_b, sl_b = find_optimal_agents(calls_b, config)
    agents_c, asa_c, sl_c = find_optimal_agents(calls_c, config)
    
    results.append({
        'date': date,
        'time': time,
        'weekday_flg': weekday_flg,
        # Ã‡aÄŸrÄ± sayÄ±larÄ±
        'calls_a': calls_a,
        'calls_b': calls_b,
        'calls_c': calls_c,
        # Base agent ihtiyaÃ§larÄ±
        'base_agents_a': agents_a,
        'base_agents_b': agents_b,
        'base_agents_c': agents_c,
        'base_total': agents_a + agents_b + agents_c,
        # ASA deÄŸerleri
        'asa_a': round(asa_a, 1),
        'asa_b': round(asa_b, 1),
        'asa_c': round(asa_c, 1),
        # SL deÄŸerleri
        'sl_a': round(sl_a * 100, 1),
        'sl_b': round(sl_b * 100, 1),
        'sl_c': round(sl_c * 100, 1)
    })

return pd.DataFrame(results)
```

# ============================================================================

# BÃ–LÃœM 3: FAZLALIK HESAPLAMA

# ============================================================================

def calculate_surplus(base_df, config):
â€œâ€â€
ADIM 2: Mevcut kadro vs Base ihtiyaÃ§ karÅŸÄ±laÅŸtÄ±rmasÄ±
Fazla kapasiteyi bul
â€œâ€â€
staff = config[â€˜staffâ€™]

```
# Her kuyruk iÃ§in max base ihtiyaÃ§ (tÃ¼m dÃ¶nem)
max_base_a = base_df['base_agents_a'].max()
max_base_b = base_df['base_agents_b'].max()
max_base_c = base_df['base_agents_c'].max()

# Hafta iÃ§i ve hafta sonu ayrÄ± max
weekday_df = base_df[base_df['weekday_flg'] == 1]
weekend_df = base_df[base_df['weekday_flg'] == 0]

weekday_max_b = weekday_df['base_agents_b'].max() if len(weekday_df) > 0 else 0
weekday_max_c = weekday_df['base_agents_c'].max() if len(weekday_df) > 0 else 0
weekend_max_b = weekend_df['base_agents_b'].max() if len(weekend_df) > 0 else 0
weekend_max_c = weekend_df['base_agents_c'].max() if len(weekend_df) > 0 else 0

# Fazla kapasite (yardÄ±ma gidebilecek)
surplus_b_weekday = max(0, staff['queue_b'] - weekday_max_b)
surplus_c_weekday = max(0, staff['queue_c'] - weekday_max_c)

surplus = {
    'staff': staff,
    'max_base': {
        'queue_a': max_base_a,
        'queue_b': max_base_b,
        'queue_c': max_base_c
    },
    'weekday_max': {
        'queue_b': weekday_max_b,
        'queue_c': weekday_max_c
    },
    'weekend_max': {
        'queue_b': weekend_max_b,
        'queue_c': weekend_max_c
    },
    'surplus_weekday': {
        'queue_b': surplus_b_weekday,
        'queue_c': surplus_c_weekday,
        'total': surplus_b_weekday + surplus_c_weekday
    }
}

return surplus
```

# ============================================================================

# BÃ–LÃœM 4: YARDIMLAÅMA UYGULA - FÄ°NAL Ä°HTÄ°YAÃ‡

# ============================================================================

def apply_help_rules(base_df, surplus, config):
â€œâ€â€
ADIM 3: Hafta iÃ§i yardÄ±mlaÅŸmayÄ± uygula
B ve C fazlasÄ± Aâ€™ya yardÄ±m eder
â€œâ€â€
results = []

```
help_rules = config['help_rules']
total_help_capacity = surplus['surplus_weekday']['total']

for idx, row in base_df.iterrows():
    weekday_flg = row['weekday_flg']
    
    # Base deÄŸerleri kopyala
    result = {
        'date': row['date'],
        'time': row['time'],
        'weekday_flg': weekday_flg,
        'calls_a': row['calls_a'],
        'calls_b': row['calls_b'],
        'calls_c': row['calls_c'],
        'base_agents_a': row['base_agents_a'],
        'base_agents_b': row['base_agents_b'],
        'base_agents_c': row['base_agents_c'],
        'base_total': row['base_total']
    }
    
    if weekday_flg == 1 and help_rules['weekday_only']:
        # Hafta iÃ§i: YardÄ±mlaÅŸma VAR
        
        # B'nin bu saatteki fazlasÄ±
        b_surplus_now = max(0, config['staff']['queue_b'] - row['base_agents_b'])
        # C'nin bu saatteki fazlasÄ±
        c_surplus_now = max(0, config['staff']['queue_c'] - row['base_agents_c'])
        
        # Toplam yardÄ±m kapasitesi (o an iÃ§in)
        help_available = 0
        if help_rules['b_helps_a']:
            help_available += b_surplus_now
        if help_rules['c_helps_a']:
            help_available += c_surplus_now
        
        # A'nÄ±n ihtiyacÄ±ndan yardÄ±mÄ± dÃ¼ÅŸ
        help_used = min(help_available, row['base_agents_a'])
        final_agents_a = max(0, row['base_agents_a'] - help_used)
        
        # B ve C tam kadro Ã§alÄ±ÅŸÄ±r (fazlasÄ± A'ya yardÄ±m ediyor)
        final_agents_b = config['staff']['queue_b']
        final_agents_c = config['staff']['queue_c']
        
        result['help_from_b'] = min(b_surplus_now, help_used) if help_rules['b_helps_a'] else 0
        result['help_from_c'] = min(c_surplus_now, help_used - result['help_from_b']) if help_rules['c_helps_a'] else 0
        result['total_help'] = result['help_from_b'] + result['help_from_c']
        
        result['final_agents_a'] = final_agents_a
        result['final_agents_b'] = row['base_agents_b']  # Sadece kendi iÅŸi iÃ§in gereken
        result['final_agents_c'] = row['base_agents_c']  # Sadece kendi iÅŸi iÃ§in gereken
        result['final_total'] = final_agents_a + row['base_agents_b'] + row['base_agents_c']
        
    else:
        # Hafta sonu: YardÄ±mlaÅŸma YOK
        result['help_from_b'] = 0
        result['help_from_c'] = 0
        result['total_help'] = 0
        result['final_agents_a'] = row['base_agents_a']
        result['final_agents_b'] = row['base_agents_b']
        result['final_agents_c'] = row['base_agents_c']
        result['final_total'] = row['base_total']
    
    results.append(result)

return pd.DataFrame(results)
```

# ============================================================================

# BÃ–LÃœM 5: VARDÄ°YA BÄ°RLEÅTÄ°RME VE OPTÄ°MÄ°ZASYON

# ============================================================================

def load_and_merge_shifts(excel_path):
â€œâ€â€œVardiya Excelâ€™ini oku ve ÅŸirketleri birleÅŸtirâ€â€â€
df = pd.read_excel(excel_path)
df.columns = df.columns.str.strip().str.lower()

```
merged = {}

for shift_name in df['shift'].unique():
    shift_data = df[df['shift'] == shift_name]
    
    def time_to_str(val):
        if hasattr(val, 'strftime'):
            return val.strftime('%H:%M')
        return str(val).strip()
    
    if len(shift_data) >= 2:
        company1 = shift_data[shift_data['company'].str.contains('1', na=False)]
        if len(company1) > 0:
            merged[shift_name] = {
                'start': time_to_str(company1['start'].values[0]),
                'end': time_to_str(company1['end'].values[0])
            }
        else:
            merged[shift_name] = {
                'start': time_to_str(shift_data['start'].values[0]),
                'end': time_to_str(shift_data['end'].values[0])
            }
    else:
        merged[shift_name] = {
            'start': time_to_str(shift_data['start'].values[0]),
            'end': time_to_str(shift_data['end'].values[0])
        }

return merged
```

def create_shifts_coverage(merged_shifts):
â€œâ€â€œVardiyalarÄ± pyworkforce formatÄ±na Ã§evirâ€â€â€
coverage = {}

```
for shift_name, times in merged_shifts.items():
    start_str = times['start']
    end_str = times['end']
    
    start_hour = int(start_str.split(':')[0])
    end_hour = int(end_str.split(':')[0])
    
    end_min = int(end_str.split(':')[1]) if ':' in end_str else 0
    if end_min >= 30:
        end_hour = (end_hour + 1) % 24
    
    hours = [0] * 24
    
    if end_hour > start_hour:
        for h in range(start_hour, end_hour):
            hours[h] = 1
    elif end_hour < start_hour:
        for h in range(start_hour, 24):
            hours[h] = 1
        for h in range(0, end_hour):
            hours[h] = 1
    else:
        hours[start_hour] = 1
    
    coverage[shift_name] = hours

return coverage
```

def prepare_required_resources_by_queue(final_df, queue_col):
â€œâ€â€œBelirli kuyruk iÃ§in gÃ¼n x saat matrisiâ€â€â€
required = []

```
for date in sorted(final_df['date'].unique()):
    day_data = final_df[final_df['date'] == date].copy()
    day_data['hour'] = day_data['time'].apply(lambda x: int(str(x).split(':')[0]))
    day_data = day_data.sort_values('hour')
    
    hourly_agents = [0] * 24
    for _, row in day_data.iterrows():
        hour = row['hour']
        hourly_agents[hour] = int(row[queue_col])
    
    required.append(hourly_agents)

return required
```

def optimize_shifts_by_queue(final_df, merged_shifts, config, queue_name, queue_col):
â€œâ€â€œTek kuyruk iÃ§in vardiya optimizasyonuâ€â€â€
required = prepare_required_resources_by_queue(final_df, queue_col)
shifts_coverage = create_shifts_coverage(merged_shifts)

```
num_days = len(required)
max_need = max(max(day) for day in required) if required else 0

if max_need == 0:
    return None

try:
    scheduler = MinRequiredResources(
        num_days=num_days,
        periods=24,
        shifts_coverage=shifts_coverage,
        required_resources=required,
        max_period_concurrency=config['optimization']['max_period_concurrency'],
        max_shift_concurrency=config['optimization']['max_shift_concurrency'],
        max_search_time=config['optimization']['max_search_time']
    )
    
    solution = scheduler.solve()
    return solution
    
except Exception as e:
    print(f"   âŒ {queue_name} optimizasyon hatasÄ±: {e}")
    return None
```

def optimize_all_queues(final_df, merged_shifts, config):
â€œâ€â€œTÃ¼m kuyruklar iÃ§in optimizasyonâ€â€â€
solutions = {}

```
queues = [
    ('Queue A', 'final_agents_a'),
    ('Queue B', 'final_agents_b'),
    ('Queue C', 'final_agents_c')
]

for queue_name, queue_col in queues:
    print(f"   ğŸ”§ {queue_name} optimizasyonu...")
    solution = optimize_shifts_by_queue(final_df, merged_shifts, config, queue_name, queue_col)
    
    if solution and solution['status'] == 'OPTIMAL':
        print(f"      âœ… {queue_name}: OPTIMAL (maliyet: {solution['cost']})")
        solutions[queue_col] = solution
    else:
        status = solution['status'] if solution else 'Hata'
        print(f"      âš ï¸ {queue_name}: {status}")
        solutions[queue_col] = None

return solutions
```

def solutions_to_dataframe(solutions, final_df, merged_shifts):
â€œâ€â€œTÃ¼m Ã§Ã¶zÃ¼mleri tek DataFrameâ€™e birleÅŸtirâ€â€â€
dates = sorted(final_df[â€˜dateâ€™].unique())
results_dict = {}

```
queue_mapping = {
    'final_agents_a': 'agents_a',
    'final_agents_b': 'agents_b',
    'final_agents_c': 'agents_c'
}

for queue_col, solution in solutions.items():
    if solution is None or solution['status'] != 'OPTIMAL':
        continue
    
    agent_col = queue_mapping[queue_col]
    
    for item in solution['resources_shifts']:
        day_idx = item['day']
        shift = item['shift']
        resources = item['resources']
        
        date = dates[day_idx] if day_idx < len(dates) else f'Day {day_idx}'
        key = (date, shift)
        
        if key not in results_dict:
            results_dict[key] = {'agents_a': 0, 'agents_b': 0, 'agents_c': 0}
        results_dict[key][agent_col] = resources

results = []
for (date, shift), agents in results_dict.items():
    if agents['agents_a'] > 0 or agents['agents_b'] > 0 or agents['agents_c'] > 0:
        shift_times = merged_shifts.get(shift, {'start': '-', 'end': '-'})
        
        results.append({
            'date': date,
            'shift': shift,
            'shift_hours': f"{shift_times['start']}-{shift_times['end']}",
            'agents_a': agents['agents_a'],
            'agents_b': agents['agents_b'],
            'agents_c': agents['agents_c'],
            'total_agents': agents['agents_a'] + agents['agents_b'] + agents['agents_c']
        })

if not results:
    return None

df = pd.DataFrame(results)
df = df.sort_values(['date', 'shift']).reset_index(drop=True)

return df
```

# ============================================================================

# BÃ–LÃœM 6: SL VE COMPLIANCE HESAPLAMA

# ============================================================================

def calculate_daily_sl(final_df):
â€œâ€â€œGÃ¼nlÃ¼k SL hesaplaâ€â€â€
daily_results = []

```
for date in sorted(final_df['date'].unique()):
    day_data = final_df[final_df['date'] == date]
    
    total_calls = day_data['calls_a'].sum() + day_data['calls_b'].sum() + day_data['calls_c'].sum()
    
    # AÄŸÄ±rlÄ±klÄ± SL (base_df'den alÄ±nacak, ÅŸimdilik basit ortalama)
    daily_results.append({
        'date': date,
        'weekday_flg': day_data['weekday_flg'].iloc[0],
        'total_calls': int(total_calls),
        'total_agents': int(day_data['final_total'].mean())
    })

return pd.DataFrame(daily_results)
```

def calculate_compliance_rate(daily_sl_df, min_sl=75, max_sl=85):
â€œâ€â€œCompliance rate hesaplaâ€â€â€
# Bu versiyonda basitleÅŸtirilmiÅŸ
return {
â€˜total_daysâ€™: len(daily_sl_df),
â€˜target_rangeâ€™: fâ€™%{min_sl}-%{max_sl}â€™
}

# ============================================================================

# BÃ–LÃœM 7: RAPORLAMA

# ============================================================================

def print_surplus_report(surplus):
â€œâ€â€œFazlalÄ±k raporuâ€â€â€
print(â€\nâ€ + â€œ=â€ * 60)
print(â€œğŸ“Š FAZLALIK RAPORUâ€)
print(â€=â€ * 60)

```
print("\nğŸ¢ MEVCUT KADRO:")
for q, count in surplus['staff'].items():
    print(f"   {q}: {count} agent")

print("\nğŸ“ˆ MAX BASE Ä°HTÄ°YAÃ‡ (TÃ¼m DÃ¶nem):")
for q, count in surplus['max_base'].items():
    print(f"   {q}: {count} agent")

print("\nğŸ“… HAFTA Ä°Ã‡Ä° MAX Ä°HTÄ°YAÃ‡:")
print(f"   Queue B: {surplus['weekday_max']['queue_b']} agent")
print(f"   Queue C: {surplus['weekday_max']['queue_c']} agent")

print("\nğŸ FAZLA KAPASÄ°TE (Hafta Ä°Ã§i A'ya YardÄ±m):")
print(f"   Queue B fazlasÄ±: {surplus['surplus_weekday']['queue_b']} agent")
print(f"   Queue C fazlasÄ±: {surplus['surplus_weekday']['queue_c']} agent")
print(f"   TOPLAM YARDIM: {surplus['surplus_weekday']['total']} agent")
```

def print_shift_summary(vardiya_df):
â€œâ€â€œVardiya Ã¶zet raporuâ€â€â€
if vardiya_df is None or len(vardiya_df) == 0:
print(â€œVardiya verisi yok!â€)
return

```
print("\n" + "=" * 60)
print("ğŸ“‹ VARDÄ°YA BAZLI Ã–ZET")
print("=" * 60)

summary = vardiya_df.groupby(['shift', 'shift_hours']).agg({
    'agents_a': ['mean', 'max'],
    'agents_b': ['mean', 'max'],
    'agents_c': ['mean', 'max'],
    'total_agents': ['mean', 'max']
}).round(0).astype(int)

summary.columns = ['A_Ort', 'A_Max', 'B_Ort', 'B_Max', 'C_Ort', 'C_Max', 'Top_Ort', 'Top_Max']
print(summary.to_string())

print("\nğŸ“Š GÃœNLÃœK Ã–ZET:")
daily = vardiya_df.groupby('date').agg({
    'agents_a': 'sum',
    'agents_b': 'sum',
    'agents_c': 'sum',
    'total_agents': 'sum'
})
print(f"   Queue A - Ort: {daily['agents_a'].mean():.0f}, Max: {daily['agents_a'].max()}")
print(f"   Queue B - Ort: {daily['agents_b'].mean():.0f}, Max: {daily['agents_b'].max()}")
print(f"   Queue C - Ort: {daily['agents_c'].mean():.0f}, Max: {daily['agents_c'].max()}")
print(f"   TOPLAM  - Ort: {daily['total_agents'].mean():.0f}, Max: {daily['total_agents'].max()}")
```

def export_results(base_df, final_df, vardiya_df, surplus):
â€œâ€â€œSonuÃ§larÄ± Excelâ€™e kaydetâ€â€â€
today = datetime.now().strftime(â€™%Y%m%dâ€™)

```
# Base senaryo
base_df.to_excel(f'{today}_base_interval.xlsx', index=False)

# Final (yardÄ±mlaÅŸma sonrasÄ±)
final_df.to_excel(f'{today}_final_interval.xlsx', index=False)

# Vardiya
if vardiya_df is not None:
    vardiya_df.to_excel(f'{today}_final_vardiya.xlsx', index=False)

# FazlalÄ±k raporu
surplus_df = pd.DataFrame([
    {'Metrik': 'Mevcut A', 'DeÄŸer': surplus['staff']['queue_a']},
    {'Metrik': 'Mevcut B', 'DeÄŸer': surplus['staff']['queue_b']},
    {'Metrik': 'Mevcut C', 'DeÄŸer': surplus['staff']['queue_c']},
    {'Metrik': 'Max Base A', 'DeÄŸer': surplus['max_base']['queue_a']},
    {'Metrik': 'Max Base B', 'DeÄŸer': surplus['max_base']['queue_b']},
    {'Metrik': 'Max Base C', 'DeÄŸer': surplus['max_base']['queue_c']},
    {'Metrik': 'B FazlasÄ± (Hafta iÃ§i)', 'DeÄŸer': surplus['surplus_weekday']['queue_b']},
    {'Metrik': 'C FazlasÄ± (Hafta iÃ§i)', 'DeÄŸer': surplus['surplus_weekday']['queue_c']},
    {'Metrik': 'Toplam YardÄ±m Kapasitesi', 'DeÄŸer': surplus['surplus_weekday']['total']}
])
surplus_df.to_excel(f'{today}_fazlalik.xlsx', index=False)

print(f"\nâœ… Dosyalar kaydedildi:")
print(f"   - {today}_base_interval.xlsx")
print(f"   - {today}_final_interval.xlsx")
print(f"   - {today}_final_vardiya.xlsx")
print(f"   - {today}_fazlalik.xlsx")
```

# ============================================================================

# ANA FONKSÄ°YON

# ============================================================================

def calculate_complete_planning(df, shift_excel):
â€œâ€â€
Komple kapasite planlamasÄ± - KatmanlÄ± yaklaÅŸÄ±m
â€œâ€â€

```
print("=" * 70)
print("KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V4 (KATMANLI + YARDIMLAÅMA)")
print("=" * 70)

print(f"\nâš™ï¸ KonfigÃ¼rasyon:")
print(f"   AHT: {CONFIG['aht']} saniye")
print(f"   Hedef ASA: â‰¤ {CONFIG['target_asa']} saniye")
print(f"   Shrinkage: %{CONFIG['shrinkage']*100}")
print(f"   Mevcut Kadro: A={CONFIG['staff']['queue_a']}, B={CONFIG['staff']['queue_b']}, C={CONFIG['staff']['queue_c']}")

# ADIM 1: VardiyalarÄ± yÃ¼kle
print(f"\nğŸ“‚ ADIM 1: Vardiyalar yÃ¼kleniyor...")
merged_shifts = load_and_merge_shifts(shift_excel)
print(f"   âœ… {len(merged_shifts)} vardiya birleÅŸtirildi")

# ADIM 2: Base senaryo
print(f"\nğŸ“Š ADIM 2: Base senaryo hesaplanÄ±yor...")
base_df = calculate_base_requirements(df, CONFIG)
print(f"   âœ… {len(base_df)} interval hesaplandÄ±")
print(f"   Max Base A: {base_df['base_agents_a'].max()}")
print(f"   Max Base B: {base_df['base_agents_b'].max()}")
print(f"   Max Base C: {base_df['base_agents_c'].max()}")

# ADIM 3: FazlalÄ±k hesapla
print(f"\nğŸ“ˆ ADIM 3: FazlalÄ±k hesaplanÄ±yor...")
surplus = calculate_surplus(base_df, CONFIG)
print(f"   âœ… B fazlasÄ±: {surplus['surplus_weekday']['queue_b']} agent")
print(f"   âœ… C fazlasÄ±: {surplus['surplus_weekday']['queue_c']} agent")
print(f"   âœ… Toplam yardÄ±m kapasitesi: {surplus['surplus_weekday']['total']} agent")

# ADIM 4: YardÄ±mlaÅŸma uygula
print(f"\nğŸ¤ ADIM 4: YardÄ±mlaÅŸma uygulanÄ±yor...")
final_df = apply_help_rules(base_df, surplus, CONFIG)

weekday_data = final_df[final_df['weekday_flg'] == 1]
weekend_data = final_df[final_df['weekday_flg'] == 0]

print(f"   âœ… Hafta iÃ§i ortalama toplam: {weekday_data['final_total'].mean():.0f} agent")
if len(weekend_data) > 0:
    print(f"   âœ… Hafta sonu ortalama toplam: {weekend_data['final_total'].mean():.0f} agent")

# ADIM 5: Vardiya optimizasyonu
print(f"\nğŸ”§ ADIM 5: Vardiya optimizasyonu...")
solutions = optimize_all_queues(final_df, merged_shifts, CONFIG)
vardiya_df = solutions_to_dataframe(solutions, final_df, merged_shifts)

# ADIM 6: Raporlar
print_surplus_report(surplus)
print_shift_summary(vardiya_df)

print("\n" + "=" * 70)
print("âœ… TAMAMLANDI!")
print("=" * 70)

return base_df, final_df, vardiya_df, surplus, solutions
```

# ============================================================================

# KULLANIM

# ============================================================================

if **name** == â€˜**main**â€™:
print(â€â€â€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V4                                   â•‘
â•‘  KatmanlÄ± Hesaplama + YardÄ±mlaÅŸma + Vardiya Optimizasyonu         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KURULUM:
pip install pyworkforce pandas openpyxl

VERÄ° FORMATI:
Kolonlar: date, time, queue_a, queue_b, queue_c, weekday_flg

```
weekday_flg: 1 = Hafta iÃ§i, 0 = Hafta sonu
```

KULLANIM:

# Veriyi oku

df = pd.read_excel(â€˜cagri_tahminleri.xlsxâ€™)

# Hesapla

base_df, final_df, vardiya_df, surplus, solutions = calculate_complete_planning(
df,
shift_excel=â€˜vardiyalar.xlsxâ€™
)

# Kaydet

export_results(base_df, final_df, vardiya_df, surplus)
â€œâ€â€)