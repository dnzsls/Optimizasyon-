â€œâ€â€
KOMPLE KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V3
ASA BazlÄ± Agent Hesaplama + pyworkforce Vardiya Optimizasyonu

Kurulum:
pip install pyworkforce pandas openpyxl

Ã–zellikler:
- Erlang C ile ASA bazlÄ± agent ihtiyacÄ±
- pyworkforce MinRequiredResources ile vardiya optimizasyonu
- Åirket bazlÄ± vardiya birleÅŸtirme
- AylÄ±k SL ve Compliance takibi
â€œâ€â€

import pandas as pd
import math
from pyworkforce.scheduling import MinRequiredResources

# ============================================================================

# KONFIGURASYON

# ============================================================================

CONFIG = {
â€˜ahtâ€™: 188,              # Average Handle Time - saniye
â€˜target_asaâ€™: 30,        # Hedef ASA - saniye
â€˜target_slâ€™: 0.80,       # Hedef Service Level - %80 (aylÄ±k kontrol)
â€˜target_secondsâ€™: 30,    # SL iÃ§in hedef sÃ¼re - saniye
â€˜shrinkageâ€™: 0.10,       # Mola/izin payÄ± - %10
â€˜interval_minutesâ€™: 60,  # Ä°nterval - dakika
â€˜complianceâ€™: {
â€˜min_slâ€™: 75,        # Compliance alt sÄ±nÄ±r %
â€˜max_slâ€™: 85         # Compliance Ã¼st sÄ±nÄ±r %
},
â€˜optimizationâ€™: {
â€˜max_period_concurrencyâ€™: 1500,   # Saatte max agent
â€˜max_shift_concurrencyâ€™: 800,     # Vardiyada max agent
â€˜max_search_timeâ€™: 300.0          # Max Ã§Ã¶zÃ¼m sÃ¼resi (saniye)
}
}

# ============================================================================

# BÃ–LÃœM 1: ERLANG C TEMELLERÄ°

# ============================================================================

def erlang_c(agents, traffic):
â€œâ€â€œErlang C: Kuyrukta bekleme olasÄ±lÄ±ÄŸÄ±â€â€â€
if agents <= traffic or agents == 0:
return 1.0

```
erlang_b = traffic / agents
for i in range(2, int(agents) + 1):
    erlang_b = (traffic * erlang_b) / (i + traffic * erlang_b)

erlang_c_val = erlang_b / (1 - (traffic / agents) * (1 - erlang_b))
return min(erlang_c_val, 1.0)
```

def calculate_asa(agents, traffic, aht):
â€œâ€â€œASA (Average Speed to Answer) hesapla - saniyeâ€â€â€
if agents <= traffic or agents == 0:
return 999

```
ec = erlang_c(agents, traffic)
asa = (ec * (aht / 60)) / (agents - traffic) * 60
return asa
```

def calculate_service_level(agents, traffic, aht, target_seconds):
â€œâ€â€œService Level hesapla - %X Ã§aÄŸrÄ± Y saniye iÃ§indeâ€â€â€
if agents <= traffic or agents == 0:
return 0.0

```
ec = erlang_c(agents, traffic)
exp_term = math.exp(-(agents - traffic) * (target_seconds / aht))
sl = 1 - (ec * exp_term)
return max(0, min(1, sl))
```

def calculate_traffic(calls, interval_min, aht):
â€œâ€â€œTraffic (Erlang) hesaplaâ€â€â€
if calls == 0:
return 0
return (calls * (aht / 60)) / interval_min

# ============================================================================

# BÃ–LÃœM 2: AGENT SAYISI BULMA (SADECE ASA BAZLI)

# ============================================================================

def find_agents_for_asa(calls, interval_min, aht, target_asa):
â€œâ€â€œASA hedefi iÃ§in gereken agent sayÄ±sÄ±â€â€â€
if calls == 0:
return 0

```
traffic = calculate_traffic(calls, interval_min, aht)
if traffic == 0:
    return 0

min_agents = math.ceil(traffic)
max_agents = math.ceil(traffic * 2) + 5

for agents in range(min_agents, max_agents + 1):
    asa = calculate_asa(agents, traffic, aht)
    if asa <= target_asa:
        return agents

return max_agents
```

def find_optimal_agents(calls, config):
â€œâ€â€œSadece ASA bazlÄ± agent hesabÄ±â€â€â€
if calls == 0:
return 0, 0, 0

```
agents_raw = find_agents_for_asa(
    calls, 
    config['interval_minutes'],
    config['aht'],
    config['target_asa']
)

agents_final = math.ceil(agents_raw / (1 - config['shrinkage']))

traffic = calculate_traffic(calls, config['interval_minutes'], config['aht'])
final_asa = calculate_asa(agents_raw, traffic, config['aht'])
final_sl = calculate_service_level(agents_raw, traffic, config['aht'], config['target_seconds'])

return agents_final, final_asa, final_sl
```

# ============================================================================

# BÃ–LÃœM 3: INTERVAL BAZLI Ä°HTÄ°YAÃ‡

# ============================================================================

def calculate_interval_requirements(df, config):
â€œâ€â€œHer interval iÃ§in agent ihtiyacÄ±nÄ± hesaplaâ€â€â€
results = []

```
for idx, row in df.iterrows():
    date = row['date']
    time = row['time']
    
    if hasattr(time, 'strftime'):
        time = time.strftime('%H:%M')
    elif not isinstance(time, str):
        time = str(time)
    
    calls_a = row['queue_a']
    calls_b = row['queue_b']
    
    agents_a, final_asa_a, final_sl_a = find_optimal_agents(calls_a, config)
    agents_b, final_asa_b, final_sl_b = find_optimal_agents(calls_b, config)
    
    results.append({
        'date': date,
        'time': time,
        'calls_a': calls_a,
        'calls_b': calls_b,
        'agents_a': agents_a,
        'agents_b': agents_b,
        'total_agents': agents_a + agents_b,
        'asa_a': round(final_asa_a, 1),
        'sl_a': round(final_sl_a * 100, 1),
        'asa_b': round(final_asa_b, 1),
        'sl_b': round(final_sl_b * 100, 1)
    })

return pd.DataFrame(results)
```

# ============================================================================

# BÃ–LÃœM 4: GÃœNLÃœK, AYLIK SL ve COMPLIANCE

# ============================================================================

def calculate_daily_sl(interval_df):
â€œâ€â€œGÃ¼nlÃ¼k Service Levelâ€â€â€
daily_results = []

```
for date in sorted(interval_df['date'].unique()):
    day_data = interval_df[interval_df['date'] == date]
    
    total_calls_a = day_data['calls_a'].sum()
    total_calls_b = day_data['calls_b'].sum()
    
    weighted_sl_a = (day_data['calls_a'] * day_data['sl_a']).sum() / total_calls_a if total_calls_a > 0 else 0
    weighted_sl_b = (day_data['calls_b'] * day_data['sl_b']).sum() / total_calls_b if total_calls_b > 0 else 0
    
    total_calls = total_calls_a + total_calls_b
    daily_sl = ((total_calls_a * weighted_sl_a) + (total_calls_b * weighted_sl_b)) / total_calls if total_calls > 0 else 0
    
    daily_results.append({
        'date': date,
        'total_calls': int(total_calls),
        'daily_sl_a': round(weighted_sl_a, 2),
        'daily_sl_b': round(weighted_sl_b, 2),
        'daily_sl_overall': round(daily_sl, 2)
    })

return pd.DataFrame(daily_results)
```

def calculate_monthly_sl(interval_df):
â€œâ€â€œAylÄ±k Service Levelâ€â€â€
total_calls_a = interval_df[â€˜calls_aâ€™].sum()
total_calls_b = interval_df[â€˜calls_bâ€™].sum()

```
weighted_sl_a = (interval_df['calls_a'] * interval_df['sl_a']).sum() / total_calls_a if total_calls_a > 0 else 0
weighted_sl_b = (interval_df['calls_b'] * interval_df['sl_b']).sum() / total_calls_b if total_calls_b > 0 else 0

total_calls = total_calls_a + total_calls_b
overall_sl = ((total_calls_a * weighted_sl_a) + (total_calls_b * weighted_sl_b)) / total_calls if total_calls > 0 else 0

return {
    'total_calls_a': int(total_calls_a),
    'total_calls_b': int(total_calls_b),
    'total_calls': int(total_calls),
    'monthly_sl_a': round(weighted_sl_a, 2),
    'monthly_sl_b': round(weighted_sl_b, 2),
    'overall_sl': round(overall_sl, 2),
    'target_met': overall_sl >= CONFIG['target_sl'] * 100
}
```

def calculate_compliance_rate(daily_sl_df, min_sl=75, max_sl=85):
â€œâ€â€œGÃ¼nlerin kaÃ§ta kaÃ§Ä± hedef aralÄ±kta?â€â€â€
total_days = len(daily_sl_df)

```
if total_days == 0:
    return None

compliant_days = daily_sl_df[
    (daily_sl_df['daily_sl_overall'] >= min_sl) & 
    (daily_sl_df['daily_sl_overall'] <= max_sl)
]

compliant_count = len(compliant_days)
compliance_rate = (compliant_count / total_days) * 100

below = daily_sl_df[daily_sl_df['daily_sl_overall'] < min_sl]
above = daily_sl_df[daily_sl_df['daily_sl_overall'] > max_sl]

return {
    'total_days': total_days,
    'compliant_days': compliant_count,
    'compliance_rate': round(compliance_rate, 1),
    'days_below': len(below),
    'days_above': len(above),
    'below_list': below[['date', 'daily_sl_overall']].to_dict('records'),
    'above_list': above[['date', 'daily_sl_overall']].to_dict('records'),
    'target_range': f'%{min_sl}-%{max_sl}'
}
```

# ============================================================================

# BÃ–LÃœM 5: VARDÄ°YA BÄ°RLEÅTÄ°RME VE PYWORKFORCE ENTEGRASYONU

# ============================================================================

def load_and_merge_shifts(excel_path):
â€œâ€â€
Vardiya Excelâ€™ini oku ve ÅŸirketleri birleÅŸtir
KesiÅŸen vardiyalarda 1.company, tek ÅŸirkette o ÅŸirketin saatini al
â€œâ€â€
df = pd.read_excel(excel_path)

```
# Kolon isimlerini temizle
df.columns = df.columns.str.strip().str.lower()

merged = {}

for shift_name in df['shift'].unique():
    shift_data = df[df['shift'] == shift_name]
    
    # Start/end deÄŸerlerini string'e Ã§evir
    def time_to_str(val):
        if hasattr(val, 'strftime'):
            return val.strftime('%H:%M')
        return str(val).strip()
    
    if len(shift_data) >= 2:
        # Ä°ki ÅŸirket de var â†’ 1.company saatlerini al
        company1 = shift_data[shift_data['company'].str.contains('1', na=False)]
        if len(company1) > 0:
            merged[shift_name] = {
                'start': time_to_str(company1['start'].values[0]),
                'end': time_to_str(company1['end'].values[0])
            }
        else:
            # 1.company yoksa ilk satÄ±rÄ± al
            merged[shift_name] = {
                'start': time_to_str(shift_data['start'].values[0]),
                'end': time_to_str(shift_data['end'].values[0])
            }
    else:
        # Tek ÅŸirket â†’ o ÅŸirketin saatini al
        merged[shift_name] = {
            'start': time_to_str(shift_data['start'].values[0]),
            'end': time_to_str(shift_data['end'].values[0])
        }

return merged
```

def create_shifts_coverage(merged_shifts):
â€œâ€â€
BirleÅŸtirilmiÅŸ vardiyalarÄ± pyworkforce formatÄ±na Ã§evir
Her vardiya iÃ§in 24 saatlik 0/1 dizisi
â€œâ€â€
coverage = {}

```
for shift_name, times in merged_shifts.items():
    start_str = times['start']
    end_str = times['end']
    
    # Saat deÄŸerini Ã§Ä±kar (07:00 â†’ 7, 07:30 â†’ 7)
    start_hour = int(start_str.split(':')[0])
    end_hour = int(end_str.split(':')[0])
    
    # 30 dakika varsa bir sonraki saate yuvarla (bitiÅŸ iÃ§in)
    end_min = int(end_str.split(':')[1]) if ':' in end_str else 0
    if end_min >= 30:
        end_hour = (end_hour + 1) % 24
    
    # 24 saatlik dizi oluÅŸtur
    hours = [0] * 24
    
    if end_hour > start_hour:
        # Normal vardiya (Ã¶rn: 07:00-16:00)
        for h in range(start_hour, end_hour):
            hours[h] = 1
    elif end_hour < start_hour:
        # Gece vardiyasÄ± (Ã¶rn: 22:00-06:00)
        for h in range(start_hour, 24):
            hours[h] = 1
        for h in range(0, end_hour):
            hours[h] = 1
    else:
        # AynÄ± saat (24 saatlik vardiya veya hata)
        hours[start_hour] = 1
    
    coverage[shift_name] = hours

return coverage
```

def prepare_required_resources(interval_df):
â€œâ€â€
interval_dfâ€™i pyworkforce formatÄ±na Ã§evir
Her satÄ±r bir gÃ¼n, her sÃ¼tun bir saat (24 saat)
â€œâ€â€
required = []

```
for date in sorted(interval_df['date'].unique()):
    day_data = interval_df[interval_df['date'] == date].copy()
    
    # Saat deÄŸerini Ã§Ä±kar
    day_data['hour'] = day_data['time'].apply(lambda x: int(str(x).split(':')[0]))
    day_data = day_data.sort_values('hour')
    
    # 24 saatlik dizi oluÅŸtur
    hourly_agents = [0] * 24
    for _, row in day_data.iterrows():
        hour = row['hour']
        hourly_agents[hour] = int(row['total_agents'])
    
    required.append(hourly_agents)

return required
```

def optimize_shifts(interval_df, merged_shifts, config):
â€œâ€â€
pyworkforce ile vardiya optimizasyonu
â€œâ€â€
# Verileri hazÄ±rla
required_resources = prepare_required_resources(interval_df)
shifts_coverage = create_shifts_coverage(merged_shifts)

```
num_days = len(required_resources)

print(f"\nğŸ“Š Optimizasyon Verileri:")
print(f"   GÃ¼n sayÄ±sÄ±: {num_days}")
print(f"   Vardiya sayÄ±sÄ±: {len(shifts_coverage)}")
print(f"   GÃ¼nlÃ¼k max ihtiyaÃ§: {max(max(day) for day in required_resources)}")

# Optimizasyonu Ã§alÄ±ÅŸtÄ±r
try:
    scheduler = MinRequiredResources(
        num_days=num_days,
        periods=24,
        shifts_coverage=shifts_coverage,
        required_resources=required_resources,
        max_period_concurrency=config['optimization']['max_period_concurrency'],
        max_shift_concurrency=config['optimization']['max_shift_concurrency'],
        max_search_time=config['optimization']['max_search_time']
    )
    
    solution = scheduler.solve()
    
    return solution
    
except Exception as e:
    print(f"âŒ Optimizasyon hatasÄ±: {e}")
    return None
```

def solution_to_dataframe(solution, interval_df):
â€œâ€â€
Optimizasyon sonucunu DataFrameâ€™e Ã§evir
â€œâ€â€
if solution is None or solution[â€˜statusâ€™] != â€˜OPTIMALâ€™:
return None

```
dates = sorted(interval_df['date'].unique())

results = []
for item in solution['resources_shifts']:
    day_idx = item['day']
    shift = item['shift']
    resources = item['resources']
    
    if resources > 0:
        results.append({
            'date': dates[day_idx] if day_idx < len(dates) else f'Day {day_idx}',
            'shift': shift,
            'agents': resources
        })

return pd.DataFrame(results)
```

# ============================================================================

# ANA FONKSÄ°YON

# ============================================================================

def calculate_complete_planning(df, shift_excel):
â€œâ€â€
Komple kapasite planlamasÄ±
ASA bazlÄ± hesaplama + pyworkforce optimizasyonu
â€œâ€â€

```
print("=" * 80)
print("KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V3 (PYWORKFORCE)")
print("=" * 80)

print(f"\nâš™ï¸ KonfigÃ¼rasyon:")
print(f"   AHT: {CONFIG['aht']} saniye")
print(f"   Hedef ASA: â‰¤ {CONFIG['target_asa']} saniye")
print(f"   Hedef AylÄ±k SL: â‰¥ %{CONFIG['target_sl']*100}")
print(f"   Shrinkage: %{CONFIG['shrinkage']*100}")

# BÃ–LÃœM 1: VardiyalarÄ± yÃ¼kle ve birleÅŸtir
print(f"\nğŸ“‚ BÃ–LÃœM 1: Vardiyalar yÃ¼kleniyor...")
merged_shifts = load_and_merge_shifts(shift_excel)
print(f"   âœ… {len(merged_shifts)} vardiya birleÅŸtirildi")

for name, times in list(merged_shifts.items())[:5]:
    print(f"      {name}: {times['start']} - {times['end']}")
if len(merged_shifts) > 5:
    print(f"      ... ve {len(merged_shifts) - 5} vardiya daha")

# BÃ–LÃœM 2: Interval bazlÄ± hesaplama
print(f"\nâš™ï¸ BÃ–LÃœM 2: Agent ihtiyacÄ± hesaplanÄ±yor...")
interval_df = calculate_interval_requirements(df, CONFIG)
print(f"   âœ… {len(interval_df)} interval hesaplandÄ±")
print(f"   Peak agent: {interval_df['total_agents'].max()}")
print(f"   Ortalama agent: {interval_df['total_agents'].mean():.0f}")

# BÃ–LÃœM 3: GÃ¼nlÃ¼k ve AylÄ±k SL
print(f"\nğŸ“Š BÃ–LÃœM 3: SL metrikleri hesaplanÄ±yor...")
daily_sl_df = calculate_daily_sl(interval_df)
monthly_sl = calculate_monthly_sl(interval_df)
compliance = calculate_compliance_rate(
    daily_sl_df, 
    CONFIG['compliance']['min_sl'], 
    CONFIG['compliance']['max_sl']
)

print(f"   âœ… AylÄ±k SL: %{monthly_sl['overall_sl']}")
print(f"   {'âœ… KARÅILANDI' if monthly_sl['target_met'] else 'âŒ KARÅILANMADI'}")
print(f"   âœ… Compliance Rate: %{compliance['compliance_rate']} ({compliance['compliant_days']}/{compliance['total_days']} gÃ¼n)")

# BÃ–LÃœM 4: Vardiya optimizasyonu
print(f"\nğŸ”§ BÃ–LÃœM 4: Vardiya optimizasyonu Ã§alÄ±ÅŸÄ±yor...")
solution = optimize_shifts(interval_df, merged_shifts, CONFIG)

if solution and solution['status'] == 'OPTIMAL':
    print(f"   âœ… Optimizasyon baÅŸarÄ±lÄ±!")
    print(f"   Toplam maliyet (agent-gÃ¼n): {solution['cost']}")
    
    vardiya_df = solution_to_dataframe(solution, interval_df)
    
    # Ã–zet istatistikler
    if vardiya_df is not None and len(vardiya_df) > 0:
        daily_total = vardiya_df.groupby('date')['agents'].sum()
        print(f"   GÃ¼nlÃ¼k ortalama agent: {daily_total.mean():.0f}")
        print(f"   GÃ¼nlÃ¼k max agent: {daily_total.max()}")
else:
    print(f"   âŒ Optimizasyon baÅŸarÄ±sÄ±z: {solution['status'] if solution else 'Hata'}")
    vardiya_df = None

print("\n" + "=" * 80)
print("âœ… TAMAMLANDI!")
print("=" * 80)

return interval_df, vardiya_df, daily_sl_df, monthly_sl, compliance, solution
```

# ============================================================================

# YARDIMCI FONKSÄ°YONLAR

# ============================================================================

def print_shift_summary(vardiya_df):
â€œâ€â€œVardiya bazlÄ± Ã¶zet raporâ€â€â€
if vardiya_df is None or len(vardiya_df) == 0:
print(â€œVardiya verisi yok!â€)
return

```
print("\nğŸ“‹ VARDÄ°YA BAZLI Ã–ZET:")
print("-" * 50)

summary = vardiya_df.groupby('shift')['agents'].agg(['mean', 'min', 'max', 'sum'])
summary.columns = ['Ortalama', 'Min', 'Max', 'Toplam']
summary = summary.round(0).astype(int)

print(summary.to_string())

print(f"\nğŸ“Š GÃœNLÃœK Ã–ZET:")
print("-" * 50)
daily = vardiya_df.groupby('date')['agents'].sum()
print(f"   Ortalama: {daily.mean():.0f} agent/gÃ¼n")
print(f"   Min: {daily.min()} agent/gÃ¼n")
print(f"   Max: {daily.max()} agent/gÃ¼n")
```

def export_results(interval_df, vardiya_df, daily_sl_df, prefix=â€˜sonucâ€™):
â€œâ€â€œSonuÃ§larÄ± Excelâ€™e kaydetâ€â€â€
interval_df.to_excel(fâ€™{prefix}_interval.xlsxâ€™, index=False)
daily_sl_df.to_excel(fâ€™{prefix}_gunluk_sl.xlsxâ€™, index=False)

```
if vardiya_df is not None:
    vardiya_df.to_excel(f'{prefix}_vardiya.xlsx', index=False)

print(f"âœ… Dosyalar kaydedildi: {prefix}_*.xlsx")
```

# ============================================================================

# KULLANIM

# ============================================================================

if **name** == â€˜**main**â€™:
print(â€â€â€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  KAPASÄ°TE PLANLAMA SÄ°STEMÄ° - V3                               â•‘
â•‘  ASA BazlÄ± + pyworkforce Optimizasyonu                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KURULUM:
pip install pyworkforce pandas openpyxl

KULLANIM:

# Veriyi oku

df = pd.read_excel(â€˜cagri_tahminleri.xlsxâ€™)

# 15dkâ€™yÄ± saate topla (eÄŸer gerekliyse)

df[â€˜hourâ€™] = pd.to_datetime(df[â€˜timeâ€™], format=â€™%H:%Mâ€™).dt.hour
df_hourly = df.groupby([â€˜dateâ€™, â€˜hourâ€™]).agg({
â€˜queue_aâ€™: â€˜sumâ€™,
â€˜queue_bâ€™: â€˜sumâ€™
}).reset_index()
df_hourly[â€˜timeâ€™] = df_hourly[â€˜hourâ€™].apply(lambda x: fâ€™{x:02d}:00â€™)

# Hesapla

interval_df, vardiya_df, daily_sl_df, monthly_sl, compliance, solution = calculate_complete_planning(
df_hourly,
shift_excel=â€˜vardiyalar.xlsxâ€™
)

# Ã–zet rapor

print_shift_summary(vardiya_df)

# Kaydet

export_results(interval_df, vardiya_df, daily_sl_df, prefix=â€˜sonucâ€™)

print(fâ€AylÄ±k SL: %{monthly_sl[â€˜overall_slâ€™]}â€)
print(fâ€Compliance Rate: %{compliance[â€˜compliance_rateâ€™]}â€)
â€œâ€â€)